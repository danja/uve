This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-04T10:44:26.385Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------
User Provided Header:
-----------------------
UVE repo

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
_src_/
  js/
    app.js
    foaf-example.js
    uve-core.js
spec/
  core/
    eventBusSpec.js
  support/
    jasmine.json
src/
  core/
    config.js
    eventBus.js
  examples/
    foafExample.js
  model/
    entityTypes/
      classEntity.js
      interfaceEntity.js
      relationshipEntity.js
    conceptModel.js
    rdfModel.js
  styles/
    main.css
  util/
    idGenerator.js
  view/
    rdfView/
      rdfFileView.js
    threeView/
      components/
        controls.js
        pipe.js
        port.js
      sphere.js
      threeView.js
  app.js
.gitignore
jsdoc.config.json
LICENSE
package.json
README.md
repomix.config.json
vite.config.js
webpack.config.js

================================================================
Files
================================================================

================
File: _src_/js/app.js
================
/**
 * Main application for UVE
 */
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// Import UVE components
import './uve-core.js';
import './foaf-example.js';

// Make THREE and OrbitControls available globally
window.THREE = THREE;
window.OrbitControls = OrbitControls;

document.addEventListener('DOMContentLoaded', function () {
    // Get container element
    const container = document.getElementById('container');

    // Create UVE application
    const app = new UVE.UVEApp({
        three: THREE // Pass Three.js instance
    });

    // Initialize the application
    app.initialize(container);

    // Set up button to load FOAF example
    const loadFOAFButton = document.getElementById('loadFOAF');
    loadFOAFButton.addEventListener('click', function () {
        UVE.FOAF.loadFOAFExample(app);
    });

    // Load FOAF example automatically
    UVE.FOAF.loadFOAFExample(app);

    // Log a message to console
    console.log('UVE application initialized');
});

================
File: _src_/js/foaf-example.js
================
/**
 * FOAF (Friend of a Friend) example implementation for UVE
 * Vanilla JavaScript version
 */

// Add to UVE namespace
window.UVE = window.UVE || {};

// FOAF example module
UVE.FOAF = {};

/**
 * Create a FOAF dataset with 5 friends
 * @returns {Object} Dataset containing FOAF data
 */
UVE.FOAF.createFOAFExample = function () {
    // Define people data
    const people = [
        {
            id: 'alice',
            label: 'Alice Smith',
            email: 'alice@example.org',
            interests: ['Semantic Web', 'Artificial Intelligence', 'Rock Climbing'],
            knows: ['bob', 'charlie', 'dave']
        },
        {
            id: 'bob',
            label: 'Bob Johnson',
            email: 'bob@example.org',
            interests: ['Machine Learning', 'Photography', 'Chess'],
            knows: ['alice', 'charlie', 'eve']
        },
        {
            id: 'charlie',
            label: 'Charlie Brown',
            email: 'charlie@example.org',
            interests: ['Data Science', 'Piano', 'Hiking'],
            knows: ['alice', 'bob', 'dave']
        },
        {
            id: 'dave',
            label: 'Dave Williams',
            email: 'dave@example.org',
            interests: ['Virtual Reality', 'Guitar', 'Mountain Biking'],
            knows: ['alice', 'charlie']
        },
        {
            id: 'eve',
            label: 'Eve Davis',
            email: 'eve@example.org',
            interests: ['Cryptography', 'Painting', 'Yoga'],
            knows: ['bob']
        }
    ];

    // Create a class for Person
    const personClass = {
        id: 'Person',
        label: 'Person',
        type: 'class',
        description: 'A person in the FOAF network',
        properties: ['name', 'email', 'knows', 'interests']
    };

    // Create relationship types
    const relationships = [];

    // Process people and create relationships
    people.forEach(person => {
        person.type = 'Person';
        person.uri = `http://example.org/people/${person.id}`;

        // Add knows relationships
        person.knows.forEach(friendId => {
            relationships.push({
                source: person.id,
                target: friendId,
                type: 'knows',
                label: 'knows'
            });
        });
    });

    return {
        classes: [personClass, ...people],
        relationships: relationships
    };
};

/**
 * Load the FOAF example into UVE
 * @param {UVE.UVEApp} app - UVE application instance
 */
UVE.FOAF.loadFOAFExample = function (app) {
    // Clear any existing objects
    app.clearScene();

    // Create the FOAF dataset
    const dataset = UVE.FOAF.createFOAFExample();

    // Load it into the model manager
    app.modelManager.loadData(dataset);

    // Create spheres for each person
    UVE.FOAF.createPersonSpheres(app, dataset);

    // Notify that data has been loaded
    app.eventBus.publish(new UVE.UVEEvent('rdf:loaded', {
        source: 'foaf-example',
        size: dataset.classes.length
    }));
};

/**
 * Create 3D spheres for people in the FOAF example
 * @param {UVE.UVEApp} app - UVE application instance
 * @param {Object} dataset - The FOAF dataset
 */
UVE.FOAF.createPersonSpheres = function (app, dataset) {
    // Filter for only person instances (not the class definition)
    const people = dataset.classes.filter(item => item.type === 'Person');

    // Color palette for spheres
    const colors = [0x3498db, 0xe74c3c, 0x2ecc71, 0xf39c12, 0x9b59b6];

    // Create a sphere for each person
    people.forEach((person, index) => {
        // Calculate position in a circle
        const angle = (index / people.length) * Math.PI * 2;
        const radius = 8;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        // Create geometry
        const geometry = new THREE.SphereGeometry(1.5, 32, 32);

        // Create material with unique color
        const material = new THREE.MeshStandardMaterial({
            color: colors[index % colors.length],
            transparent: true,
            opacity: 0.8,
            metalness: 0.2,
            roughness: 0.5
        });

        // Create mesh
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(x, 0, z);

        // Store metadata
        sphere.userData = {
            personId: person.id,
            name: person.label,
            email: person.email,
            interests: person.interests
        };

        // Add to scene
        app.scene.add(sphere);
        app.objects.set(person.id, sphere);

        // Add label above the sphere
        UVE.FOAF.addPersonLabel(app, sphere, person.label);
    });

    // Create relationship lines
    UVE.FOAF.createRelationshipLines(app, dataset);
};

/**
 * Add a text label above a person sphere
 * @param {UVE.UVEApp} app - UVE application instance
 * @param {THREE.Mesh} sphere - The person's sphere
 * @param {string} name - Person's name
 */
UVE.FOAF.addPersonLabel = function (app, sphere, name) {
    // Create canvas for text
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 128;

    // Fill background
    context.fillStyle = 'rgba(255, 255, 255, 0.8)';
    context.fillRect(0, 0, canvas.width, canvas.height);

    // Add text
    context.font = 'bold 24px Arial';
    context.fillStyle = '#000000';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(name, canvas.width / 2, canvas.height / 2);

    // Create texture
    const texture = new THREE.CanvasTexture(canvas);

    // Create sprite material
    const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true
    });

    // Create sprite
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(2.5, 1.25, 1);
    sprite.position.y = 2.5; // Position above sphere

    // Add to sphere
    sphere.add(sprite);
};

/**
 * Create relationship lines between people
 * @param {UVE.UVEApp} app - UVE application instance
 * @param {Object} dataset - The FOAF dataset
 */
UVE.FOAF.createRelationshipLines = function (app, dataset) {
    // Create a line for each relationship
    dataset.relationships.forEach(rel => {
        const sourceSphere = app.objects.get(rel.source);
        const targetSphere = app.objects.get(rel.target);

        if (sourceSphere && targetSphere) {
            // Create points for the line
            const sourcePos = sourceSphere.position.clone();
            const targetPos = targetSphere.position.clone();

            // Create a curved line
            const mid = sourcePos.clone().add(targetPos).multiplyScalar(0.5);
            mid.y += 2; // Add a slight curve upward

            // Create a curve
            const curve = new THREE.QuadraticBezierCurve3(
                sourcePos,
                mid,
                targetPos
            );

            // Create points along the curve
            const points = curve.getPoints(20);

            // Create geometry
            const geometry = new THREE.BufferGeometry().setFromPoints(points);

            // Create material
            const material = new THREE.LineBasicMaterial({
                color: 0x999999,
                linewidth: 2
            });

            // Create line
            const line = new THREE.Line(geometry, material);

            // Add to scene
            app.scene.add(line);

            // Add relationship label
            UVE.FOAF.addRelationshipLabel(app, mid, rel.label);
        }
    });
};

/**
 * Add a label to a relationship line
 * @param {UVE.UVEApp} app - UVE application instance
 * @param {THREE.Vector3} position - Position of the label
 * @param {string} text - Label text
 */
UVE.FOAF.addRelationshipLabel = function (app, position, text) {
    // Create canvas for text
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 128;
    canvas.height = 64;

    // Fill background
    context.fillStyle = 'rgba(255, 255, 255, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);

    // Add text
    context.font = '16px Arial';
    context.fillStyle = '#000000';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, canvas.width / 2, canvas.height / 2);

    // Create texture
    const texture = new THREE.CanvasTexture(canvas);

    // Create sprite material
    const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true
    });

    // Create sprite
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(1.5, 0.75, 1);
    sprite.position.copy(position);

    // Add to scene
    app.scene.add(sprite);
};

================
File: _src_/js/uve-core.js
================
/**
 * UVE core architecture implementation
 * Vanilla JavaScript version
 */

// Create a namespace for UVE
window.UVE = window.UVE || {};

// Base class for all UVE event types
UVE.UVEEvent = class {
    /**
     * Create a new UVE event
     * @param {string} type - The event type
     * @param {Object} data - Event data
     */
    constructor(type, data = {}) {
        this.type = type;
        this.data = data;
        this.timestamp = Date.now();
    }
};

// Event bus for UVE system-wide messaging
UVE.EventBus = class {
    constructor() {
        this.subscribers = new Map();
    }

    /**
     * Subscribe to events of a specific type
     * @param {string} eventType - Type of event to subscribe to
     * @param {Function} callback - Function to call when event occurs
     * @returns {Function} Unsubscribe function
     */
    subscribe(eventType, callback) {
        if (!this.subscribers.has(eventType)) {
            this.subscribers.set(eventType, new Set());
        }

        this.subscribers.get(eventType).add(callback);

        // Return unsubscribe function
        return () => {
            const subs = this.subscribers.get(eventType);
            if (subs) {
                subs.delete(callback);
                if (subs.size === 0) {
                    this.subscribers.delete(eventType);
                }
            }
        };
    }

    /**
     * Publish an event to all subscribers
     * @param {UVEEvent} event - The event to publish
     */
    publish(event) {
        const subs = this.subscribers.get(event.type);
        if (subs) {
            subs.forEach(callback => {
                try {
                    callback(event);
                } catch (error) {
                    console.error(`Error in event handler for ${event.type}:`, error);
                }
            });
        }
    }
};

// Base class for all model objects
UVE.ModelObject = class {
    /**
     * Create a new model object
     * @param {EventBus} eventBus - The system event bus
     * @param {string} id - Unique identifier for this object
     */
    constructor(eventBus, id) {
        this.eventBus = eventBus;
        this.id = id;
        this.properties = new Map();
    }

    /**
     * Get a property value
     * @param {string} key - Property name
     * @param {*} defaultValue - Default value if property doesn't exist
     * @returns {*} Property value
     */
    get(key, defaultValue = null) {
        return this.properties.has(key) ? this.properties.get(key) : defaultValue;
    }

    /**
     * Set a property value and notify subscribers
     * @param {string} key - Property name
     * @param {*} value - Property value
     */
    set(key, value) {
        const oldValue = this.get(key);
        this.properties.set(key, value);

        this.eventBus.publish(new UVE.UVEEvent('model:property:change', {
            modelId: this.id,
            property: key,
            oldValue,
            newValue: value
        }));
    }
};

// Simple RDF Model Manager (placeholder implementation)
UVE.RDFModelManager = class {
    constructor(eventBus) {
        this.eventBus = eventBus;
        this.classMap = new Map();
    }

    loadData(data) {
        // In a real implementation, this would parse RDF data
        // For now, we'll just store it directly

        if (data.classes) {
            data.classes.forEach(classData => {
                const modelObj = new UVE.ModelObject(this.eventBus, classData.id);
                Object.entries(classData).forEach(([key, value]) => {
                    modelObj.set(key, value);
                });

                this.classMap.set(classData.id, modelObj);
            });

            // Notify that classes have been loaded
            this.eventBus.publish(new UVE.UVEEvent('rdf:classes:extracted', {
                count: this.classMap.size,
                modelManager: this
            }));
        }
    }

    getClasses() {
        return Array.from(this.classMap.values());
    }
};

// Main UVE application
UVE.UVEApp = class {
    /**
     * Create the UVE application
     * @param {Object} config - Configuration options
     */
    constructor(config = {}) {
        this.config = config;
        this.eventBus = new UVE.EventBus();
        this.three = config.three || THREE;
        this.modelManager = new UVE.RDFModelManager(this.eventBus);
        this.views = [];
        this.objects = new Map();
    }

    /**
     * Initialize the application
     * @param {HTMLElement} container - DOM container for Three.js
     */
    initialize(container) {
        // Create scene
        this.scene = new this.three.Scene();
        this.scene.background = new this.three.Color(0xf0f0f0);

        // Create camera
        this.camera = new this.three.PerspectiveCamera(
            75,
            container.clientWidth / container.clientHeight,
            0.1,
            1000
        );
        this.camera.position.z = 10;

        // Create renderer
        this.renderer = new this.three.WebGLRenderer({ antialias: true });
        this.renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(this.renderer.domElement);

        // Add orbit controls - using the globally available OrbitControls
        this.controls = new OrbitControls(
            this.camera,
            this.renderer.domElement
        );
        this.controls.enableDamping = true;

        // Add ambient light
        const ambientLight = new this.three.AmbientLight(0x404040);
        this.scene.add(ambientLight);

        // Add directional light
        const directionalLight = new this.three.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        this.scene.add(directionalLight);

        // Animation loop
        const animate = () => {
            requestAnimationFrame(animate);
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        };

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            this.camera.aspect = container.clientWidth / container.clientHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(container.clientWidth, container.clientHeight);
        });
    }

    /**
     * Clear all objects from the scene
     */
    clearScene() {
        // Remove all spheres and lines (but keep lights and camera)
        for (let i = this.scene.children.length - 1; i >= 0; i--) {
            const obj = this.scene.children[i];
            if (obj.type === 'Mesh' || obj.type === 'Line' || obj.type === 'Sprite') {
                this.scene.remove(obj);
            }
        }
        this.objects.clear();
    }
};

================
File: spec/core/eventBusSpec.js
================
/**
 * Tests for the EventBus module
 */

import eventBus from '../../src/core/eventBus.js';

describe('EventBus', () => {
  // Clear all subscribers before each test
  beforeEach(() => {
    eventBus.clear();
  });

  // Test subscribe and publish functionality
  it('should allow subscribing to events', () => {
    const callback = jasmine.createSpy('callback');
    eventBus.subscribe('test-event', callback);
    
    eventBus.publish('test-event', { data: 'test' });
    expect(callback).toHaveBeenCalledWith({ data: 'test' });
  });
  
  // Test multiple subscribers
  it('should call multiple subscribers for the same event', () => {
    const callback1 = jasmine.createSpy('callback1');
    const callback2 = jasmine.createSpy('callback2');
    
    eventBus.subscribe('test-event', callback1);
    eventBus.subscribe('test-event', callback2);
    
    eventBus.publish('test-event', { data: 'test' });
    
    expect(callback1).toHaveBeenCalledWith({ data: 'test' });
    expect(callback2).toHaveBeenCalledWith({ data: 'test' });
  });
  
  // Test unsubscribe functionality
  it('should allow unsubscribing from events', () => {
    const callback = jasmine.createSpy('callback');
    const unsubscribe = eventBus.subscribe('test-event', callback);
    
    // First publication should trigger callback
    eventBus.publish('test-event', { data: 'test1' });
    expect(callback).toHaveBeenCalledWith({ data: 'test1' });
    
    // Unsubscribe
    unsubscribe();
    
    // Reset call count
    callback.calls.reset();
    
    // Second publication should not trigger callback
    eventBus.publish('test-event', { data: 'test2' });
    expect(callback).not.toHaveBeenCalled();
  });
  
  // Test error handling in callbacks
  it('should handle errors in subscribers', () => {
    const goodCallback = jasmine.createSpy('goodCallback');
    const badCallback = jasmine.createSpy('badCallback').and.throwError('Test error');
    
    eventBus.subscribe('test-event', badCallback);
    eventBus.subscribe('test-event', goodCallback);
    
    // This should not throw, despite the error in badCallback
    expect(() => {
      eventBus.publish('test-event', { data: 'test' });
    }).not.toThrow();
    
    // The good callback should still be called
    expect(goodCallback).toHaveBeenCalledWith({ data: 'test' });
  });
  
  // Test clearing all subscribers
  it('should allow clearing all subscribers', () => {
    const callback1 = jasmine.createSpy('callback1');
    const callback2 = jasmine.createSpy('callback2');
    
    eventBus.subscribe('event1', callback1);
    eventBus.subscribe('event2', callback2);
    
    eventBus.clear();
    
    eventBus.publish('event1', { data: 'test' });
    eventBus.publish('event2', { data: 'test' });
    
    expect(callback1).not.toHaveBeenCalled();
    expect(callback2).not.toHaveBeenCalled();
  });
  
  // Test clearing specific event subscribers
  it('should allow clearing subscribers for a specific event', () => {
    const callback1 = jasmine.createSpy('callback1');
    const callback2 = jasmine.createSpy('callback2');
    
    eventBus.subscribe('event1', callback1);
    eventBus.subscribe('event2', callback2);
    
    eventBus.clear('event1');
    
    eventBus.publish('event1', { data: 'test' });
    eventBus.publish('event2', { data: 'test' });
    
    expect(callback1).not.toHaveBeenCalled();
    expect(callback2).toHaveBeenCalledWith({ data: 'test' });
  });
});

================
File: spec/support/jasmine.json
================
{
  "spec_dir": "spec",
  "spec_files": [
    "**/*[sS]pec.?(m)js"
  ],
  "helpers": [
    "helpers/**/*.?(m)js"
  ],
  "env": {
    "stopSpecOnExpectationFailure": false,
    "random": true
  }
}

================
File: src/core/config.js
================
/**
 * System configuration for UVE
 * Contains default settings and constants
 * @module core/config
 */

const config = {
  // RDF Configuration
  rdf: {
    defaultNamespaces: {
      rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
      rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
      owl: 'http://www.w3.org/2002/07/owl#',
      xsd: 'http://www.w3.org/2001/XMLSchema#',
      foaf: 'http://xmlns.com/foaf/0.1/',
      uve: 'http://uve.example.org/ns#'
    },
    // RDF types for the UVE model
    types: {
      class: 'http://www.w3.org/2000/01/rdf-schema#Class',
      property: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#Property',
      interface: 'http://uve.example.org/ns#Interface',
      subClassOf: 'http://www.w3.org/2000/01/rdf-schema#subClassOf'
    }
  },
  
  // Visualization Configuration
  visualization: {
    // Class sphere settings
    sphere: {
      defaultRadius: 5,
      minRadius: 2,
      maxRadius: 10,
      defaultColor: 0x6495ED, // Cornflower blue
      selectedColor: 0xFFD700, // Gold
      opacity: 0.7,
      segments: 32
    },
    
    // Relationship pipe settings
    pipe: {
      defaultRadius: 0.3,
      defaultColor: 0x4682B4, // Steel blue
      selectedColor: 0xFFA500, // Orange
      segments: 8
    },
    
    // Interface port settings
    port: {
      defaultRadius: 0.5,
      defaultColor: 0x32CD32, // Lime green
      selectedColor: 0xFF4500, // Orange red
      segments: 16
    },
    
    // Camera settings
    camera: {
      fov: 75,
      near: 0.1,
      far: 1000,
      position: { x: 0, y: 0, z: 15 }
    },
    
    // Controls
    controls: {
      movementSpeed: 0.5,
      lookSpeed: 0.1
    }
  },
  
  // System settings
  system: {
    logLevel: 'info', // Possible values: trace, debug, info, warn, error
    defaultFile: 'model.ttl'
  }
};

export default config;

================
File: src/core/eventBus.js
================
/**
 * Central event bus for pub-sub messaging in UVE
 * Enables loose coupling between components
 * @module core/eventBus
 */

import log from 'loglevel';

class EventBus {
  /**
   * Create a new EventBus
   */
  constructor() {
    this.events = {};
    this.log = log.getLogger('EventBus');
  }

  /**
   * Subscribe to an event
   * @param {string} event - Event name to subscribe to
   * @param {Function} callback - Function to call when event is published
   * @returns {Function} Unsubscribe function
   */
  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    
    this.events[event].push(callback);
    this.log.debug(`Subscribed to ${event}, total subscribers: ${this.events[event].length}`);
    
    // Return unsubscribe function
    return () => {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
      this.log.debug(`Unsubscribed from ${event}, remaining subscribers: ${this.events[event].length}`);
    };
  }

  /**
   * Publish an event
   * @param {string} event - Event name to publish
   * @param {any} data - Data to pass to subscribers
   */
  publish(event, data) {
    if (!this.events[event]) {
      this.log.debug(`No subscribers for ${event}`);
      return;
    }
    
    this.log.debug(`Publishing ${event} to ${this.events[event].length} subscribers`);
    this.events[event].forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        this.log.error(`Error in subscriber callback for ${event}:`, error);
      }
    });
  }

  /**
   * Remove all subscribers for an event
   * @param {string} event - Event name to clear
   */
  clear(event) {
    if (event) {
      delete this.events[event];
      this.log.debug(`Cleared all subscribers for ${event}`);
    } else {
      this.events = {};
      this.log.debug('Cleared all subscribers for all events');
    }
  }
}

// Export a singleton instance
const eventBus = new EventBus();
export default eventBus;

================
File: src/examples/foafExample.js
================
/**
 * FOAF (Friend of a Friend) example data
 * Creates a set of 5 friends with relationships
 * @module examples/foafExample
 */

import rdf from 'rdf-ext';

/**
 * Create a FOAF example dataset with 5 friends
 * @returns {Dataset} RDF dataset with FOAF data
 */
function createFOAFExample() {
  const dataset = rdf.dataset();
  
  // Define namespaces
  const ns = {
    rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
    rdfs: rdf.namespace('http://www.w3.org/2000/01/rdf-schema#'),
    foaf: rdf.namespace('http://xmlns.com/foaf/0.1/'),
    xsd: rdf.namespace('http://www.w3.org/2001/XMLSchema#'),
    ex: rdf.namespace('http://example.org/'),
    uve: rdf.namespace('http://uve.example.org/ns#')
  };
  
  // Define FOAF classes
  dataset.add(rdf.quad(ns.foaf.Person, ns.rdf.type, ns.rdfs.Class));
  dataset.add(rdf.quad(ns.foaf.Person, ns.rdfs.label, rdf.literal('Person')));
  
  dataset.add(rdf.quad(ns.foaf.Group, ns.rdf.type, ns.rdfs.Class));
  dataset.add(rdf.quad(ns.foaf.Group, ns.rdfs.label, rdf.literal('Group')));
  
  dataset.add(rdf.quad(ns.foaf.Organization, ns.rdf.type, ns.rdfs.Class));
  dataset.add(rdf.quad(ns.foaf.Organization, ns.rdfs.label, rdf.literal('Organization')));
  
  // Add interface to Person
  dataset.add(rdf.quad(ns.ex.Identifiable, ns.rdf.type, ns.uve.Interface));
  dataset.add(rdf.quad(ns.ex.Identifiable, ns.rdfs.label, rdf.literal('Identifiable')));
  dataset.add(rdf.quad(ns.foaf.Person, ns.uve.hasInterface, ns.ex.Identifiable));
  
  // Add methods to the interface
  const getIdMethod = rdf.blankNode();
  dataset.add(rdf.quad(ns.ex.Identifiable, ns.uve.hasMethod, getIdMethod));
  dataset.add(rdf.quad(getIdMethod, ns.rdfs.label, rdf.literal('getId')));
  dataset.add(rdf.quad(getIdMethod, ns.uve.hasReturnType, rdf.literal('string')));
  
  // Add Social interface to Person
  dataset.add(rdf.quad(ns.ex.Social, ns.rdf.type, ns.uve.Interface));
  dataset.add(rdf.quad(ns.ex.Social, ns.rdfs.label, rdf.literal('Social')));
  dataset.add(rdf.quad(ns.foaf.Person, ns.uve.hasInterface, ns.ex.Social));
  
  // Add methods to the Social interface
  const addFriendMethod = rdf.blankNode();
  dataset.add(rdf.quad(ns.ex.Social, ns.uve.hasMethod, addFriendMethod));
  dataset.add(rdf.quad(addFriendMethod, ns.rdfs.label, rdf.literal('addFriend')));
  dataset.add(rdf.quad(addFriendMethod, ns.uve.hasReturnType, rdf.literal('void')));
  
  const friendParam = rdf.blankNode();
  dataset.add(rdf.quad(addFriendMethod, ns.uve.hasParameter, friendParam));
  dataset.add(rdf.quad(friendParam, ns.rdfs.label, rdf.literal('friend')));
  dataset.add(rdf.quad(friendParam, ns.uve.hasType, rdf.literal('Person')));
  
  // Define FOAF properties
  dataset.add(rdf.quad(ns.foaf.name, ns.rdf.type, ns.rdf.Property));
  dataset.add(rdf.quad(ns.foaf.name, ns.rdfs.label, rdf.literal('name')));
  dataset.add(rdf.quad(ns.foaf.name, ns.rdfs.domain, ns.foaf.Person));
  dataset.add(rdf.quad(ns.foaf.name, ns.rdfs.range, ns.xsd.string));
  
  dataset.add(rdf.quad(ns.foaf.mbox, ns.rdf.type, ns.rdf.Property));
  dataset.add(rdf.quad(ns.foaf.mbox, ns.rdfs.label, rdf.literal('email')));
  dataset.add(rdf.quad(ns.foaf.mbox, ns.rdfs.domain, ns.foaf.Person));
  dataset.add(rdf.quad(ns.foaf.mbox, ns.rdfs.range, ns.xsd.string));
  
  dataset.add(rdf.quad(ns.foaf.knows, ns.rdf.type, ns.rdf.Property));
  dataset.add(rdf.quad(ns.foaf.knows, ns.rdfs.label, rdf.literal('knows')));
  dataset.add(rdf.quad(ns.foaf.knows, ns.rdfs.domain, ns.foaf.Person));
  dataset.add(rdf.quad(ns.foaf.knows, ns.rdfs.range, ns.foaf.Person));
  
  dataset.add(rdf.quad(ns.foaf.member, ns.rdf.type, ns.rdf.Property));
  dataset.add(rdf.quad(ns.foaf.member, ns.rdfs.label, rdf.literal('member')));
  dataset.add(rdf.quad(ns.foaf.member, ns.rdfs.domain, ns.foaf.Group));
  dataset.add(rdf.quad(ns.foaf.member, ns.rdfs.range, ns.foaf.Person));
  
  // Create 5 friends
  const friends = [
    { 
      uri: ns.ex('alice'), 
      name: 'Alice', 
      email: 'alice@example.org' 
    },
    { 
      uri: ns.ex('bob'), 
      name: 'Bob', 
      email: 'bob@example.org' 
    },
    { 
      uri: ns.ex('charlie'), 
      name: 'Charlie', 
      email: 'charlie@example.org' 
    },
    { 
      uri: ns.ex('diana'), 
      name: 'Diana', 
      email: 'diana@example.org' 
    },
    { 
      uri: ns.ex('eve'), 
      name: 'Eve', 
      email: 'eve@example.org' 
    }
  ];
  
  // Add friend data to dataset
  friends.forEach(friend => {
    dataset.add(rdf.quad(friend.uri, ns.rdf.type, ns.foaf.Person));
    dataset.add(rdf.quad(friend.uri, ns.foaf.name, rdf.literal(friend.name)));
    dataset.add(rdf.quad(friend.uri, ns.foaf.mbox, rdf.literal(friend.email)));
  });
  
  // Create friendships (not all combinations, just some examples)
  // Alice knows Bob and Charlie
  dataset.add(rdf.quad(ns.ex('alice'), ns.foaf.knows, ns.ex('bob')));
  dataset.add(rdf.quad(ns.ex('alice'), ns.foaf.knows, ns.ex('charlie')));
  
  // Bob knows Alice and Diana
  dataset.add(rdf.quad(ns.ex('bob'), ns.foaf.knows, ns.ex('alice')));
  dataset.add(rdf.quad(ns.ex('bob'), ns.foaf.knows, ns.ex('diana')));
  
  // Charlie knows Alice and Eve
  dataset.add(rdf.quad(ns.ex('charlie'), ns.foaf.knows, ns.ex('alice')));
  dataset.add(rdf.quad(ns.ex('charlie'), ns.foaf.knows, ns.ex('eve')));
  
  // Diana knows Bob and Eve
  dataset.add(rdf.quad(ns.ex('diana'), ns.foaf.knows, ns.ex('bob')));
  dataset.add(rdf.quad(ns.ex('diana'), ns.foaf.knows, ns.ex('eve')));
  
  // Eve knows Charlie and Diana
  dataset.add(rdf.quad(ns.ex('eve'), ns.foaf.knows, ns.ex('charlie')));
  dataset.add(rdf.quad(ns.ex('eve'), ns.foaf.knows, ns.ex('diana')));
  
  // Create a group
  dataset.add(rdf.quad(ns.ex('friends-group'), ns.rdf.type, ns.foaf.Group));
  dataset.add(rdf.quad(ns.ex('friends-group'), ns.foaf.name, rdf.literal('Friends Group')));
  
  // Add all friends to the group
  friends.forEach(friend => {
    dataset.add(rdf.quad(ns.ex('friends-group'), ns.foaf.member, friend.uri));
  });
  
  return dataset;
}

export default createFOAFExample;

================
File: src/model/entityTypes/classEntity.js
================
/**
 * ClassEntity represents a class in the UVE model
 * Maps to a sphere in the visualization
 * @module model/entityTypes/classEntity
 */

/**
 * Entity representing a class
 */
class ClassEntity {
  /**
   * Create a new ClassEntity
   * @param {Object} params - Parameters
   * @param {Term} params.uri - RDF URI of the class
   * @param {string} params.label - Human-readable label for the class
   * @param {Array<string>} [params.interfaces=[]] - Interface URIs attached to this class
   * @param {Array<string>} [params.subclasses=[]] - Subclass URIs contained in this class
   * @param {Object} [params.position] - 3D position of the class sphere
   * @param {number} [params.position.x=0] - X coordinate
   * @param {number} [params.position.y=0] - Y coordinate
   * @param {number} [params.position.z=0] - Z coordinate
   * @param {number} [params.radius] - Radius of the class sphere, calculated from subclasses if not provided
   */
  constructor({ uri, label, interfaces = [], subclasses = [], position = { x: 0, y: 0, z: 0 }, radius }) {
    this.uri = uri;
    this.label = label;
    this.interfaces = interfaces;
    this.subclasses = subclasses;
    this.position = position;
    this._radius = radius;
    
    // Additional metadata
    this.properties = [];
    this.isSelected = false;
  }
  
  /**
   * Get the calculated or explicit radius
   * @returns {number} Radius value
   */
  get radius() {
    if (this._radius) {
      return this._radius;
    }
    
    // Calculate radius based on subclass count if not explicitly set
    const baseRadius = 5;
    const subclassMultiplier = 0.5;
    return baseRadius + (this.subclasses.length * subclassMultiplier);
  }
  
  /**
   * Set the radius explicitly
   * @param {number} value - New radius value
   */
  set radius(value) {
    this._radius = value;
  }
  
  /**
   * Add an interface to this class
   * @param {string} interfaceUri - URI of the interface to add
   */
  addInterface(interfaceUri) {
    if (!this.interfaces.includes(interfaceUri)) {
      this.interfaces.push(interfaceUri);
    }
  }
  
  /**
   * Add a subclass to this class
   * @param {string} subclassUri - URI of the subclass to add
   */
  addSubclass(subclassUri) {
    if (!this.subclasses.includes(subclassUri)) {
      this.subclasses.push(subclassUri);
    }
  }
  
  /**
   * Add a property to this class
   * @param {Object} property - Property object
   * @param {Term} property.predicate - Predicate term
   * @param {Term} property.object - Object term
   */
  addProperty(property) {
    this.properties.push(property);
  }
  
  /**
   * Serialize to JSON
   * @returns {Object} JSON representation
   */
  toJSON() {
    return {
      uri: this.uri.value,
      label: this.label,
      interfaces: this.interfaces.map(i => i.value),
      subclasses: this.subclasses.map(s => s.value),
      position: this.position,
      radius: this.radius,
      properties: this.properties.map(p => ({
        predicate: p.predicate.value,
        object: p.object.value
      }))
    };
  }
}

export default ClassEntity;

================
File: src/model/entityTypes/interfaceEntity.js
================
/**
 * InterfaceEntity represents an interface on a class
 * Maps to a port on a sphere in the visualization
 * @module model/entityTypes/interfaceEntity
 */

/**
 * Entity representing an interface
 */
class InterfaceEntity {
  /**
   * Create a new InterfaceEntity
   * @param {Object} params - Parameters
   * @param {Term} params.uri - RDF URI of the interface
   * @param {string} params.label - Human-readable label for the interface
   * @param {Term} params.classUri - URI of the class this interface belongs to
   * @param {Object} [params.position] - Spherical position on the class sphere
   * @param {number} [params.position.phi=0] - Horizontal angle (0-2π)
   * @param {number} [params.position.theta=0] - Vertical angle (0-π)
   * @param {Object} [params.metadata={}] - Additional metadata for the interface
   */
  constructor({ uri, label, classUri, position = { phi: 0, theta: 0 }, metadata = {} }) {
    this.uri = uri;
    this.label = label;
    this.classUri = classUri;
    this.position = position;
    this.metadata = metadata;
    
    // Methods provided by this interface
    this.methods = [];
    
    // Track visualization state
    this.isSelected = false;
    this.isVisible = true;
  }
  
  /**
   * Add a method to this interface
   * @param {Object} method - Method information
   * @param {string} method.name - Method name
   * @param {Array<Object>} [method.parameters=[]] - Method parameters
   * @param {string} [method.returnType] - Return type of the method
   */
  addMethod(method) {
    this.methods.push(method);
  }
  
  /**
   * Calculate a 3D position on the sphere based on spherical coordinates
   * @param {number} radius - Radius of the class sphere
   * @returns {Object} 3D coordinates {x, y, z}
   */
  getPositionOnSphere(radius) {
    const { phi, theta } = this.position;
    
    return {
      x: radius * Math.sin(theta) * Math.cos(phi),
      y: radius * Math.sin(theta) * Math.sin(phi),
      z: radius * Math.cos(theta)
    };
  }
  
  /**
   * Update the position of this interface on the sphere
   * @param {number} phi - Horizontal angle (0-2π)
   * @param {number} theta - Vertical angle (0-π)
   */
  updatePosition(phi, theta) {
    this.position.phi = phi;
    this.position.theta = theta;
  }
  
  /**
   * Toggle selection state
   * @returns {boolean} New selection state
   */
  toggleSelection() {
    this.isSelected = !this.isSelected;
    return this.isSelected;
  }
  
  /**
   * Serialize to JSON
   * @returns {Object} JSON representation
   */
  toJSON() {
    return {
      uri: this.uri.value,
      label: this.label,
      classUri: this.classUri.value,
      position: this.position,
      methods: this.methods,
      metadata: this.metadata
    };
  }
}

export default InterfaceEntity;

================
File: src/model/entityTypes/relationshipEntity.js
================
/**
 * RelationshipEntity represents a relationship between classes
 * Maps to a pipe in the visualization
 * @module model/entityTypes/relationshipEntity
 */

/**
 * Entity representing a relationship between classes
 */
class RelationshipEntity {
  /**
   * Create a new RelationshipEntity
   * @param {Object} params - Parameters
   * @param {Term} params.uri - RDF URI of the relationship property
   * @param {string} params.label - Human-readable label for the relationship
   * @param {Term} params.sourceClassUri - URI of the source class
   * @param {Term} params.targetClassUri - URI of the target class
   * @param {string} [params.type='default'] - Type of relationship
   * @param {Object} [params.metadata={}] - Additional metadata for the relationship
   */
  constructor({ uri, label, sourceClassUri, targetClassUri, type = 'default', metadata = {} }) {
    this.uri = uri;
    this.label = label;
    this.sourceClassUri = sourceClassUri;
    this.targetClassUri = targetClassUri;
    this.type = type;
    this.metadata = metadata;
    
    // Track visualization state
    this.isSelected = false;
    this.isVisible = true;
  }
  
  /**
   * Check if this relationship connects the given classes
   * @param {Term} class1Uri - First class URI
   * @param {Term} class2Uri - Second class URI
   * @returns {boolean} True if this relationship connects the classes in any direction
   */
  connectsClasses(class1Uri, class2Uri) {
    return (
      (this.sourceClassUri.equals(class1Uri) && this.targetClassUri.equals(class2Uri)) ||
      (this.sourceClassUri.equals(class2Uri) && this.targetClassUri.equals(class1Uri))
    );
  }
  
  /**
   * Get the direction of the relationship between two classes
   * @param {Term} fromClassUri - Source class URI
   * @param {Term} toClassUri - Target class URI
   * @returns {number} 1 if direction matches, -1 if reversed, 0 if not connected
   */
  getDirection(fromClassUri, toClassUri) {
    if (this.sourceClassUri.equals(fromClassUri) && this.targetClassUri.equals(toClassUri)) {
      return 1;
    } else if (this.sourceClassUri.equals(toClassUri) && this.targetClassUri.equals(fromClassUri)) {
      return -1;
    } else {
      return 0;
    }
  }
  
  /**
   * Toggle selection state
   * @returns {boolean} New selection state
   */
  toggleSelection() {
    this.isSelected = !this.isSelected;
    return this.isSelected;
  }
  
  /**
   * Serialize to JSON
   * @returns {Object} JSON representation
   */
  toJSON() {
    return {
      uri: this.uri.value,
      label: this.label,
      sourceClassUri: this.sourceClassUri.value,
      targetClassUri: this.targetClassUri.value,
      type: this.type,
      metadata: this.metadata
    };
  }
}

export default RelationshipEntity;

================
File: src/model/conceptModel.js
================
/**
 * Conceptual model that transforms RDF data into domain entities
 * @module model/conceptModel
 */

import log from 'loglevel';
import eventBus from '../core/eventBus.js';
import config from '../core/config.js';
import ClassEntity from './entityTypes/classEntity.js';
import RelationshipEntity from './entityTypes/relationshipEntity.js';
import InterfaceEntity from './entityTypes/interfaceEntity.js';

class ConceptModel {
  /**
   * Create a new ConceptModel
   * @param {RDFModel} rdfModel - RDF data model
   */
  constructor(rdfModel) {
    this.rdfModel = rdfModel;
    this.classes = new Map(); // URI string -> ClassEntity
    this.relationships = new Map(); // URI string -> RelationshipEntity
    this.interfaces = new Map(); // URI string -> InterfaceEntity
    this.log = log.getLogger('ConceptModel');
    
    // Subscribe to RDF model changes
    eventBus.subscribe('rdf-model-changed', () => this.updateFromRDF());
  }

  /**
   * Update the conceptual model from RDF data
   */
  updateFromRDF() {
    this.log.info('Updating conceptual model from RDF data');
    
    // Clear current entities
    this.classes.clear();
    this.relationships.clear();
    this.interfaces.clear();
    
    // Load classes
    this._loadClasses();
    
    // Load relationships between classes
    this._loadRelationships();
    
    // Load interfaces
    this._loadInterfaces();
    
    // Assign positions to classes (simple circle layout for now)
    this._assignPositions();
    
    // Notify that the concept model has changed
    eventBus.publish('concept-model-changed', {
      classes: Array.from(this.classes.values()),
      relationships: Array.from(this.relationships.values()),
      interfaces: Array.from(this.interfaces.values())
    });
  }

  /**
   * Load classes from RDF model
   * @private
   */
  _loadClasses() {
    const classNodes = this.rdfModel.getClasses();
    
    classNodes.forEach(classNode => {
      const uri = classNode.term;
      const uriString = uri.value;
      
      // Skip if we already have this class
      if (this.classes.has(uriString)) {
        return;
      }
      
      // Get label for the class
      const labels = classNode.out(this.rdfModel.namespaces.rdfs.label);
      const label = labels.values[0] || this._extractLabelFromUri(uriString);
      
      // Create class entity
      const classEntity = new ClassEntity({ 
        uri, 
        label,
        subclasses: []
      });
      
      // Add properties
      const properties = this.rdfModel.getProperties(uri);
      properties.forEach(property => {
        classEntity.addProperty(property);
      });
      
      this.classes.set(uriString, classEntity);
      this.log.debug(`Loaded class: ${label} (${uriString})`);
    });
    
    // Now that all classes are loaded, find subclass relationships
    this._loadSubclassRelationships();
  }
  
  /**
   * Load subclass relationships
   * @private
   */
  _loadSubclassRelationships() {
    for (const classEntity of this.classes.values()) {
      const subclasses = this.rdfModel.getSubclasses(classEntity.uri);
      
      subclasses.forEach(subclass => {
        const subclassUri = subclass.term;
        const subclassUriString = subclassUri.value;
        
        // Only process if the subclass is a known class
        if (this.classes.has(subclassUriString)) {
          classEntity.addSubclass(subclassUri);
        }
      });
    }
  }

  /**
   * Load relationships between classes
   * @private
   */
  _loadRelationships() {
    const relationships = this.rdfModel.getRelationships();
    
    relationships.forEach(rel => {
      const { property, domain, range } = rel;
      const propertyUriString = property.value;
      
      // Skip if we already have this relationship
      if (this.relationships.has(propertyUriString)) {
        return;
      }
      
      // Get label for the relationship
      const propertyNode = this.rdfModel.grapoi.node(property);
      const labels = propertyNode.out(this.rdfModel.namespaces.rdfs.label);
      const label = labels.values[0] || this._extractLabelFromUri(propertyUriString);
      
      // Create relationship entity
      const relationshipEntity = new RelationshipEntity({
        uri: property,
        label,
        sourceClassUri: domain,
        targetClassUri: range
      });
      
      this.relationships.set(propertyUriString, relationshipEntity);
      this.log.debug(`Loaded relationship: ${label} (${propertyUriString})`);
    });
  }

  /**
   * Load interfaces
   * @private
   */
  _loadInterfaces() {
    const interfaceType = this.rdfModel.namedNode(config.rdf.types.interface);
    const interfaces = this.rdfModel.grapoi.node(interfaceType).in(this.rdfModel.namespaces.rdf.type);
    
    interfaces.forEach(interfaceNode => {
      const uri = interfaceNode.term;
      const uriString = uri.value;
      
      // Skip if we already have this interface
      if (this.interfaces.has(uriString)) {
        return;
      }
      
      // Get label for the interface
      const labels = interfaceNode.out(this.rdfModel.namespaces.rdfs.label);
      const label = labels.values[0] || this._extractLabelFromUri(uriString);
      
      // Find the class this interface belongs to
      const classNodes = interfaceNode.in(this.rdfModel.namespaces.uve.hasInterface);
      
      if (classNodes.values.length === 0) {
        this.log.warn(`Interface ${label} (${uriString}) not attached to any class`);
        return;
      }
      
      const classUri = classNodes.term;
      const classUriString = classUri.value;
      
      if (!this.classes.has(classUriString)) {
        this.log.warn(`Interface ${label} attached to unknown class ${classUriString}`);
        return;
      }
      
      // Create random spherical position
      const position = {
        phi: Math.random() * Math.PI * 2, // 0 to 2π
        theta: Math.random() * Math.PI // 0 to π
      };
      
      // Create interface entity
      const interfaceEntity = new InterfaceEntity({
        uri,
        label,
        classUri,
        position
      });
      
      // Add methods to the interface (if any)
      const methods = interfaceNode.out(this.rdfModel.namespaces.uve.hasMethod);
      
      methods.forEach(methodNode => {
        const methodName = methodNode.out(this.rdfModel.namespaces.rdfs.label).values[0] ||
                          methodNode.term.value.split('#').pop().split('/').pop();
        
        const methodParams = [];
        const paramNodes = methodNode.out(this.rdfModel.namespaces.uve.hasParameter);
        
        paramNodes.forEach(paramNode => {
          const paramName = paramNode.out(this.rdfModel.namespaces.rdfs.label).values[0] ||
                           paramNode.term.value.split('#').pop().split('/').pop();
          
          const paramType = paramNode.out(this.rdfModel.namespaces.uve.hasType).values[0] || 'any';
          
          methodParams.push({
            name: paramName,
            type: paramType
          });
        });
        
        const returnType = methodNode.out(this.rdfModel.namespaces.uve.hasReturnType).values[0] || 'void';
        
        interfaceEntity.addMethod({
          name: methodName,
          parameters: methodParams,
          returnType
        });
      });
      
      this.interfaces.set(uriString, interfaceEntity);
      
      // Add interface to class
      const classEntity = this.classes.get(classUriString);
      classEntity.addInterface(uri);
      
      this.log.debug(`Loaded interface: ${label} (${uriString}) for class ${classEntity.label}`);
    });
  }

  /**
   * Assign positions to classes
   * @private
   */
  _assignPositions() {
    const classes = Array.from(this.classes.values());
    const classCount = classes.length;
    
    if (classCount === 0) {
      return;
    }
    
    // For a single class, place it at origin
    if (classCount === 1) {
      classes[0].position = { x: 0, y: 0, z: 0 };
      return;
    }
    
    // For multiple classes, arrange in a circle on the XZ plane
    const radius = Math.max(30, classCount * 5);
    const angleStep = (Math.PI * 2) / classCount;
    
    classes.forEach((classEntity, index) => {
      const angle = index * angleStep;
      
      classEntity.position = {
        x: radius * Math.sin(angle),
        y: 0,
        z: radius * Math.cos(angle)
      };
    });
  }

  /**
   * Extract a human-readable label from a URI
   * @param {string} uri - URI to extract label from
   * @returns {string} Extracted label
   * @private
   */
  _extractLabelFromUri(uri) {
    // Try to extract the fragment
    let label = uri.split('#').pop();
    
    // If no fragment, try the last path segment
    if (label === uri) {
      label = uri.split('/').pop();
    }
    
    return label;
  }

  /**
   * Get a class entity by URI
   * @param {Term|string} uri - Class URI
   * @returns {ClassEntity|null} Class entity or null if not found
   */
  getClass(uri) {
    const uriString = typeof uri === 'string' ? uri : uri.value;
    return this.classes.get(uriString) || null;
  }

  /**
   * Get relationships for a class
   * @param {Term|string} classUri - Class URI
   * @returns {Array<RelationshipEntity>} Relationships involving the class
   */
  getClassRelationships(classUri) {
    const uriString = typeof classUri === 'string' ? classUri : classUri.value;
    
    return Array.from(this.relationships.values()).filter(rel => {
      return rel.sourceClassUri.value === uriString || rel.targetClassUri.value === uriString;
    });
  }

  /**
   * Get interfaces for a class
   * @param {Term|string} classUri - Class URI
   * @returns {Array<InterfaceEntity>} Interfaces for the class
   */
  getClassInterfaces(classUri) {
    const uriString = typeof classUri === 'string' ? classUri : classUri.value;
    
    return Array.from(this.interfaces.values()).filter(intf => {
      return intf.classUri.value === uriString;
    });
  }

  /**
   * Get a relationship entity by URI
   * @param {Term|string} uri - Relationship URI
   * @returns {RelationshipEntity|null} Relationship entity or null if not found
   */
  getRelationship(uri) {
    const uriString = typeof uri === 'string' ? uri : uri.value;
    return this.relationships.get(uriString) || null;
  }

  /**
   * Get an interface entity by URI
   * @param {Term|string} uri - Interface URI
   * @returns {InterfaceEntity|null} Interface entity or null if not found
   */
  getInterface(uri) {
    const uriString = typeof uri === 'string' ? uri : uri.value;
    return this.interfaces.get(uriString) || null;
  }
}

export default ConceptModel;

================
File: src/model/rdfModel.js
================
/**
 * RDF data model for UVE
 * Manages RDF datasets using RDF-Ext and Grapoi
 * @module model/rdfModel
 */

import rdf from 'rdf-ext';
import { fromFile, toFile } from 'rdf-utils-fs';
import log from 'loglevel';
import eventBus from '../core/eventBus.js';
import config from '../core/config.js';

class RDFModel {
  /**
   * Create a new RDF Model
   */
  constructor() {
    this.dataset = rdf.dataset();
    this.grapoi = rdf.grapoi({ dataset: this.dataset });
    this.namespaces = {};
    this.log = log.getLogger('RDFModel');
    
    // Initialize namespaces
    Object.entries(config.rdf.defaultNamespaces).forEach(([prefix, uri]) => {
      this.namespaces[prefix] = rdf.namespace(uri);
    });
  }

  /**
   * Load RDF data from a Turtle file
   * @param {string} filePath - Path to the Turtle file
   * @returns {Promise<void>}
   */
  async loadFromFile(filePath) {
    try {
      this.log.info(`Loading RDF data from ${filePath}`);
      const stream = fromFile(filePath);
      
      // Clear existing dataset
      this.dataset = rdf.dataset();
      
      // Import data from stream
      await this.dataset.import(stream);
      
      // Reinitialize grapoi with new dataset
      this.grapoi = rdf.grapoi({ dataset: this.dataset });
      
      this.log.info(`Loaded ${this.dataset.size} triples from ${filePath}`);
      eventBus.publish('rdf-model-changed', { source: 'file', path: filePath });
      
      return this.dataset;
    } catch (error) {
      this.log.error(`Error loading RDF data from ${filePath}:`, error);
      throw error;
    }
  }

  /**
   * Save RDF data to a Turtle file
   * @param {string} filePath - Path to save the Turtle file
   * @returns {Promise<void>}
   */
  async saveToFile(filePath) {
    try {
      this.log.info(`Saving RDF data to ${filePath}`);
      const stream = this.dataset.toStream();
      await toFile(stream, filePath);
      this.log.info(`Saved ${this.dataset.size} triples to ${filePath}`);
    } catch (error) {
      this.log.error(`Error saving RDF data to ${filePath}:`, error);
      throw error;
    }
  }

  /**
   * Add a triple to the dataset
   * @param {Term} subject - Subject term
   * @param {Term} predicate - Predicate term
   * @param {Term} object - Object term
   */
  addTriple(subject, predicate, object) {
    const quad = rdf.quad(subject, predicate, object);
    this.dataset.add(quad);
    this.log.debug(`Added triple: ${quad.toString()}`);
    eventBus.publish('rdf-model-changed', { source: 'addTriple', quad });
  }

  /**
   * Remove a triple from the dataset
   * @param {Term} subject - Subject term
   * @param {Term} predicate - Predicate term
   * @param {Term} object - Object term
   */
  removeTriple(subject, predicate, object) {
    const matches = this.dataset.match(subject, predicate, object);
    this.dataset.deleteMatches(subject, predicate, object);
    this.log.debug(`Removed ${matches.size} triples`);
    eventBus.publish('rdf-model-changed', { source: 'removeTriple', matches });
  }

  /**
   * Get all RDF classes from the dataset
   * @returns {Grapoi} Grapoi object containing class nodes
   */
  getClasses() {
    return this.grapoi.node(this.namespaces.rdfs.Class)
      .in(this.namespaces.rdf.type);
  }

  /**
   * Get all properties for a given subject
   * @param {Term} subject - Subject term
   * @returns {Array<Object>} Array of property objects with predicate and object
   */
  getProperties(subject) {
    const properties = [];
    const matches = this.dataset.match(subject);
    
    for (const quad of matches) {
      properties.push({
        predicate: quad.predicate,
        object: quad.object
      });
    }
    
    return properties;
  }

  /**
   * Get subclasses of a given class
   * @param {Term} classUri - URI of the class
   * @returns {Grapoi} Grapoi object containing subclass nodes
   */
  getSubclasses(classUri) {
    return this.grapoi.node(classUri)
      .in(this.namespaces.rdfs.subClassOf);
  }

  /**
   * Get interfaces for a class
   * @param {Term} classUri - URI of the class
   * @returns {Grapoi} Grapoi object containing interface nodes
   */
  getInterfaces(classUri) {
    return this.grapoi.node(classUri)
      .out(this.namespaces.uve.hasInterface);
  }

  /**
   * Get relationships between classes
   * @returns {Array<Object>} Array of relationship objects
   */
  getRelationships() {
    const relationships = [];
    const properties = this.grapoi.node(this.namespaces.rdf.Property)
      .in(this.namespaces.rdf.type);
    
    for (const property of properties) {
      const domains = property.out(this.namespaces.rdfs.domain);
      const ranges = property.out(this.namespaces.rdfs.range);
      
      // For each domain-range pair, create a relationship
      for (const domain of domains) {
        for (const range of ranges) {
          relationships.push({
            property: property.term,
            domain: domain.term,
            range: range.term
          });
        }
      }
    }
    
    return relationships;
  }
  
  /**
   * Create a named node with the given URI
   * @param {string} uri - URI for the named node
   * @returns {NamedNode} RDF named node
   */
  namedNode(uri) {
    return rdf.namedNode(uri);
  }
  
  /**
   * Create a literal with the given value
   * @param {string} value - Value for the literal
   * @param {string} [datatype] - Optional datatype URI
   * @returns {Literal} RDF literal
   */
  literal(value, datatype) {
    return datatype ? 
      rdf.literal(value, null, rdf.namedNode(datatype)) : 
      rdf.literal(value);
  }
}

export default RDFModel;

================
File: src/styles/main.css
================
/**
 * Main CSS styles for UVE application
 */

/* Reset default styles */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body, html {
  height: 100%;
  width: 100%;
  font-family: Arial, sans-serif;
  overflow: hidden;
}

/* Main layout */
.app-container {
  display: flex;
  height: 100vh;
  width: 100vw;
}

.view-container {
  flex: 1;
  position: relative;
  height: 100%;
}

.view-divider {
  width: 6px;
  background-color: #333;
  cursor: col-resize;
  position: relative;
}

.view-divider::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 40px;
  background-color: #444;
  border-radius: 3px;
}

/* Three.js view styles */
#three-view-container {
  background-color: #111;
}

/* RDF view styles */
#rdf-view-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: #f5f5f5;
}

.rdf-view-toolbar {
  display: flex;
  padding: 10px;
  background-color: #2c3e50;
  color: white;
}

.rdf-view-toolbar button {
  margin-right: 10px;
  padding: 5px 10px;
  border: none;
  background-color: #3498db;
  color: white;
  border-radius: 3px;
  cursor: pointer;
}

.rdf-view-toolbar button:hover {
  background-color: #2980b9;
}

.rdf-view-toolbar select {
  padding: 5px;
  border: none;
  border-radius: 3px;
}

.rdf-view-editor {
  flex: 1;
  font-family: monospace;
  font-size: 14px;
  padding: 10px;
  border: none;
  resize: none;
  white-space: pre;
  tab-size: 2;
  background-color: #282c34;
  color: #abb2bf;
}

.rdf-view-status {
  display: flex;
  justify-content: space-between;
  padding: 5px 10px;
  background-color: #ecf0f1;
  border-top: 1px solid #bdc3c7;
}

.rdf-view-status.success::before {
  content: attr(data-message);
  color: #27ae60;
}

.rdf-view-status.error::before {
  content: attr(data-message);
  color: #e74c3c;
}

.rdf-view-count {
  color: #7f8c8d;
}

/* Navigation buttons */
.enter-class-button,
.exit-class-button {
  position: absolute;
  bottom: 20px;
  right: 20px;
  padding: 10px 15px;
  background-color: rgba(52, 152, 219, 0.8);
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  z-index: 1000;
  transition: background-color 0.3s ease;
}

.enter-class-button:hover,
.exit-class-button:hover {
  background-color: rgba(41, 128, 185, 0.9);
}

.hidden {
  display: none;
}

/* Info panel for selected objects */
.info-panel {
  position: absolute;
  top: 20px;
  right: 20px;
  width: 300px;
  background-color: rgba(44, 62, 80, 0.8);
  color: white;
  border-radius: 5px;
  padding: 15px;
  font-size: 14px;
  z-index: 1000;
  max-height: 80vh;
  overflow-y: auto;
}

.info-panel h3 {
  margin-bottom: 10px;
  font-size: 18px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  padding-bottom: 5px;
}

.info-panel h4 {
  margin: 10px 0 5px;
  font-size: 16px;
}

.info-panel p {
  margin-bottom: 8px;
}

.info-panel ul {
  margin-left: 20px;
}

.info-panel li {
  margin-bottom: 5px;
}

/* Loading indicator */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 5px solid #f3f3f3;
  border-top: 5px solid #3498db;
  border-radius: 50%;
  animation: spin 2s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Context menu */
.context-menu {
  position: absolute;
  background-color: white;
  border: 1px solid #ccc;
  border-radius: 3px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  padding: 5px 0;
  min-width: 150px;
  z-index: 1001;
}

.context-menu-item {
  padding: 8px 15px;
  cursor: pointer;
}

.context-menu-item:hover {
  background-color: #f2f2f2;
}

/* Help tooltip */
.help-tooltip {
  position: absolute;
  bottom: 20px;
  left: 20px;
  background-color: rgba(44, 62, 80, 0.8);
  color: white;
  border-radius: 5px;
  padding: 10px 15px;
  font-size: 14px;
  max-width: 300px;
  z-index: 1000;
}

.help-tooltip h4 {
  margin-bottom: 5px;
}

.help-tooltip p {
  margin-bottom: 5px;
}

.help-tooltip kbd {
  background-color: rgba(255, 255, 255, 0.2);
  padding: 2px 5px;
  border-radius: 3px;
  font-size: 12px;
}

================
File: src/util/idGenerator.js
================
/**
 * Utility for generating unique IDs
 * @module util/idGenerator
 */

/**
 * Generate a unique ID with an optional prefix
 * @param {string} [prefix='id'] - Prefix for the ID
 * @returns {string} Unique ID
 */
function generateId(prefix = 'id') {
  return `${prefix}-${Math.random().toString(36).substring(2, 11)}`;
}

/**
 * Generate a unique URI for UVE namespace
 * @param {string} localName - Local part of the URI
 * @returns {string} Full URI string
 */
function generateUveUri(localName) {
  return `http://uve.example.org/ns#${localName}`;
}

/**
 * Generate a unique blank node ID
 * @returns {string} Blank node ID
 */
function generateBlankNodeId() {
  return `b${Date.now().toString(36)}${Math.random().toString(36).substring(2, 7)}`;
}

export {
  generateId,
  generateUveUri,
  generateBlankNodeId
};

================
File: src/view/rdfView/rdfFileView.js
================
/**
 * RDFFileView provides a view for RDF data in Turtle syntax
 * @module view/rdfView/rdfFileView
 */

import log from 'loglevel';
import formatsPretty from '@rdfjs/formats/pretty.js';
import rdf from 'rdf-ext';
import eventBus from '../../core/eventBus.js';

class RDFFileView {
  /**
   * Create a new RDFFileView
   * @param {RDFModel} rdfModel - RDF data model
   * @param {HTMLElement} container - DOM element to render into
   */
  constructor(rdfModel, container) {
    this.rdfModel = rdfModel;
    this.container = container;
    this.log = log.getLogger('RDFFileView');
    
    // Setup pretty formatters
    this.prettyRdf = rdf.clone();
    this.prettyRdf.formats.import(formatsPretty);
    
    // Create editor elements
    this.createEditor();
    
    // Subscribe to RDF model changes
    eventBus.subscribe('rdf-model-changed', data => this.updateView(data));
  }
  
  /**
   * Create the editor elements
   */
  createEditor() {
    // Create toolbar
    this.toolbar = document.createElement('div');
    this.toolbar.className = 'rdf-view-toolbar';
    this.container.appendChild(this.toolbar);
    
    // Create load button
    this.loadButton = document.createElement('button');
    this.loadButton.textContent = 'Load';
    this.loadButton.addEventListener('click', () => this.loadFromFile());
    this.toolbar.appendChild(this.loadButton);
    
    // Create save button
    this.saveButton = document.createElement('button');
    this.saveButton.textContent = 'Save';
    this.saveButton.addEventListener('click', () => this.saveToFile());
    this.toolbar.appendChild(this.saveButton);
    
    // Create format selector
    this.formatSelector = document.createElement('select');
    
    const formats = [
      { value: 'text/turtle', label: 'Turtle' },
      { value: 'application/n-triples', label: 'N-Triples' },
      { value: 'application/n-quads', label: 'N-Quads' },
      { value: 'application/trig', label: 'TriG' },
      { value: 'application/ld+json', label: 'JSON-LD' }
    ];
    
    formats.forEach(format => {
      const option = document.createElement('option');
      option.value = format.value;
      option.textContent = format.label;
      this.formatSelector.appendChild(option);
    });
    
    this.formatSelector.addEventListener('change', () => this.updateView());
    this.toolbar.appendChild(this.formatSelector);
    
    // Create editor element
    this.editor = document.createElement('textarea');
    this.editor.className = 'rdf-view-editor';
    this.editor.spellcheck = false;
    this.container.appendChild(this.editor);
    
    // Create status bar
    this.statusBar = document.createElement('div');
    this.statusBar.className = 'rdf-view-status';
    this.container.appendChild(this.statusBar);
    
    // Apply button - to apply changes from editor to model
    this.applyButton = document.createElement('button');
    this.applyButton.textContent = 'Apply Changes';
    this.applyButton.addEventListener('click', () => this.applyChanges());
    this.statusBar.appendChild(this.applyButton);
    
    // Triple count
    this.tripleCount = document.createElement('span');
    this.tripleCount.className = 'rdf-view-count';
    this.statusBar.appendChild(this.tripleCount);
  }
  
  /**
   * Update the view with the current RDF model
   * @param {Object} [data] - Change data from event
   */
  async updateView(data) {
    this.log.debug('Updating RDF view', data);
    
    try {
      // Get selected format
      const format = this.formatSelector.value;
      
      // Serialize dataset to text
      const serialized = await this.prettyRdf.io.dataset.toText(format, this.rdfModel.dataset);
      
      // Update editor
      this.editor.value = serialized;
      
      // Update triple count
      this.tripleCount.textContent = `${this.rdfModel.dataset.size} triples`;
    } catch (error) {
      this.log.error('Error updating RDF view:', error);
      this.showError('Error updating view: ' + error.message);
    }
  }
  
  /**
   * Apply changes from editor to model
   */
  async applyChanges() {
    try {
      // Get text from editor
      const text = this.editor.value;
      
      // Get selected format
      const format = this.formatSelector.value;
      
      // Parse text to dataset
      const dataset = await this.prettyRdf.io.dataset.fromText(format, text);
      
      // Clear existing dataset and add new triples
      this.rdfModel.dataset.deleteMatches();
      this.rdfModel.dataset.addAll(dataset);
      
      // Notify change
      eventBus.publish('rdf-model-changed', { source: 'editor' });
      
      this.log.info(`Applied changes: ${dataset.size} triples`);
      this.showSuccess(`Applied ${dataset.size} triples`);
    } catch (error) {
      this.log.error('Error applying changes:', error);
      this.showError('Error applying changes: ' + error.message);
    }
  }
  
  /**
   * Load RDF data from a file
   */
  loadFromFile() {
    // Create file input
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.ttl,.nt,.nq,.trig,.jsonld,.json';
    
    // Handle file selection
    fileInput.addEventListener('change', async event => {
      const file = event.target.files[0];
      
      if (!file) return;
      
      try {
        // Determine format from file extension
        const format = this.getFormatFromFileName(file.name);
        
        // Read file content
        const text = await this.readFileAsText(file);
        
        // Parse text to dataset
        const dataset = await this.prettyRdf.io.dataset.fromText(format, text);
        
        // Clear existing dataset and add new triples
        this.rdfModel.dataset.deleteMatches();
        this.rdfModel.dataset.addAll(dataset);
        
        // Notify change
        eventBus.publish('rdf-model-changed', { source: 'file', path: file.name });
        
        this.log.info(`Loaded ${dataset.size} triples from ${file.name}`);
        this.showSuccess(`Loaded ${dataset.size} triples from ${file.name}`);
        
        // Select matching format in dropdown
        for (let i = 0; i < this.formatSelector.options.length; i++) {
          if (this.formatSelector.options[i].value === format) {
            this.formatSelector.selectedIndex = i;
            break;
          }
        }
      } catch (error) {
        this.log.error(`Error loading file ${file.name}:`, error);
        this.showError(`Error loading file: ${error.message}`);
      }
    });
    
    // Trigger file selection
    fileInput.click();
  }
  
  /**
   * Save RDF data to a file
   */
  async saveToFile() {
    try {
      // Get selected format
      const format = this.formatSelector.value;
      
      // Get file extension for the format
      const extension = this.getFileExtensionForFormat(format);
      
      // Serialize dataset to text
      const serialized = await this.prettyRdf.io.dataset.toText(format, this.rdfModel.dataset);
      
      // Create download link
      const blob = new Blob([serialized], { type: format });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `model${extension}`;
      
      // Trigger download
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Clean up
      URL.revokeObjectURL(url);
      
      this.log.info(`Saved ${this.rdfModel.dataset.size} triples to model${extension}`);
      this.showSuccess(`Saved ${this.rdfModel.dataset.size} triples to model${extension}`);
    } catch (error) {
      this.log.error('Error saving file:', error);
      this.showError('Error saving file: ' + error.message);
    }
  }
  
  /**
   * Read a file as text
   * @param {File} file - File to read
   * @returns {Promise<string>} File contents as text
   */
  readFileAsText(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = event => {
        resolve(event.target.result);
      };
      
      reader.onerror = error => {
        reject(error);
      };
      
      reader.readAsText(file);
    });
  }
  
  /**
   * Get format from file name
   * @param {string} fileName - File name
   * @returns {string} MIME type for the file
   */
  getFormatFromFileName(fileName) {
    const extension = fileName.split('.').pop().toLowerCase();
    
    const formatMap = {
      ttl: 'text/turtle',
      nt: 'application/n-triples',
      nq: 'application/n-quads',
      trig: 'application/trig',
      jsonld: 'application/ld+json',
      json: 'application/ld+json'
    };
    
    return formatMap[extension] || 'text/turtle';
  }
  
  /**
   * Get file extension for format
   * @param {string} format - MIME type
   * @returns {string} File extension for the format
   */
  getFileExtensionForFormat(format) {
    const extensionMap = {
      'text/turtle': '.ttl',
      'application/n-triples': '.nt',
      'application/n-quads': '.nq',
      'application/trig': '.trig',
      'application/ld+json': '.jsonld'
    };
    
    return extensionMap[format] || '.ttl';
  }
  
  /**
   * Show a success message
   * @param {string} message - Success message
   */
  showSuccess(message) {
    this.statusBar.className = 'rdf-view-status success';
    this.statusBar.setAttribute('data-message', message);
    
    // Reset after 3 seconds
    setTimeout(() => {
      this.statusBar.className = 'rdf-view-status';
    }, 3000);
  }
  
  /**
   * Show an error message
   * @param {string} message - Error message
   */
  showError(message) {
    this.statusBar.className = 'rdf-view-status error';
    this.statusBar.setAttribute('data-message', message);
    
    // Reset after 5 seconds
    setTimeout(() => {
      this.statusBar.className = 'rdf-view-status';
    }, 5000);
  }
}

export default RDFFileView;

================
File: src/view/threeView/components/controls.js
================
/**
 * First-person controls for navigating the 3D space
 * @module view/threeView/controls
 */

import * as THREE from 'three';
import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
import config from '../../core/config.js';
import eventBus from '../../core/eventBus.js';

class Controls {
  /**
   * Create first-person controls
   * @param {THREE.Camera} camera - THREE.js camera
   * @param {HTMLElement} domElement - DOM element for pointer lock
   */
  constructor(camera, domElement) {
    this.camera = camera;
    this.domElement = domElement;
    
    // Create controls
    this.controls = new PointerLockControls(camera, domElement);
    
    // Set up movement
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    this.moveUp = false;
    this.moveDown = false;
    
    // Set up movement speed
    this.velocity = new THREE.Vector3();
    this.direction = new THREE.Vector3();
    this.movementSpeed = config.visualization.controls.movementSpeed;
    
    // Set up keyboard event handlers
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onKeyUp = this.onKeyUp.bind(this);
    
    // Set up click handler for locking controls
    this.onClick = this.onClick.bind(this);
    
    // Lock/unlock handler
    this.onLockChange = this.onLockChange.bind(this);
    
    // Set up event listeners
    document.addEventListener('keydown', this.onKeyDown);
    document.addEventListener('keyup', this.onKeyUp);
    this.domElement.addEventListener('click', this.onClick);
    document.addEventListener('pointerlockchange', this.onLockChange);
    
    // Raycast for interaction
    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2();
    
    // Setup mouse move handler for raycasting
    this.onMouseMove = this.onMouseMove.bind(this);
    document.addEventListener('mousemove', this.onMouseMove);
    
    // Track intersection objects
    this.intersectedObject = null;
    
    // Click handling for object interaction
    this.onObjectClick = this.onObjectClick.bind(this);
    document.addEventListener('click', this.onObjectClick);
    
    // Keep track of selected object
    this.selectedObject = null;
  }
  
  /**
   * Handle key down events
   * @param {KeyboardEvent} event - Key down event
   */
  onKeyDown(event) {
    // Only handle events when controls are locked
    if (!this.controls.isLocked) return;
    
    switch (event.code) {
      case 'ArrowUp':
      case 'KeyW':
        this.moveForward = true;
        break;
        
      case 'ArrowLeft':
      case 'KeyA':
        this.moveLeft = true;
        break;
        
      case 'ArrowDown':
      case 'KeyS':
        this.moveBackward = true;
        break;
        
      case 'ArrowRight':
      case 'KeyD':
        this.moveRight = true;
        break;
        
      case 'KeyQ':
        this.moveDown = true;
        break;
        
      case 'KeyE':
        this.moveUp = true;
        break;
    }
  }
  
  /**
   * Handle key up events
   * @param {KeyboardEvent} event - Key up event
   */
  onKeyUp(event) {
    switch (event.code) {
      case 'ArrowUp':
      case 'KeyW':
        this.moveForward = false;
        break;
        
      case 'ArrowLeft':
      case 'KeyA':
        this.moveLeft = false;
        break;
        
      case 'ArrowDown':
      case 'KeyS':
        this.moveBackward = false;
        break;
        
      case 'ArrowRight':
      case 'KeyD':
        this.moveRight = false;
        break;
        
      case 'KeyQ':
        this.moveDown = false;
        break;
        
      case 'KeyE':
        this.moveUp = false;
        break;
    }
  }
  
  /**
   * Handle click events for locking controls
   */
  onClick() {
    if (!this.controls.isLocked) {
      this.controls.lock();
    }
  }
  
  /**
   * Handle pointer lock change
   */
  onLockChange() {
    if (document.pointerLockElement === this.domElement) {
      eventBus.publish('controls-locked', true);
    } else {
      eventBus.publish('controls-locked', false);
    }
  }
  
  /**
   * Handle mouse move events for raycasting
   * @param {MouseEvent} event - Mouse move event
   */
  onMouseMove(event) {
    // Only perform raycasting when controls are not locked
    if (this.controls.isLocked) return;
    
    // Calculate mouse position in normalized device coordinates
    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  }
  
  /**
   * Handle click events for object interaction
   * @param {MouseEvent} event - Click event
   */
  onObjectClick(event) {
    // Only handle clicks when controls are not locked
    if (this.controls.isLocked) return;
    
    // If we have an intersected object, handle the click
    if (this.intersectedObject) {
      const userData = this.intersectedObject.userData;
      
      // Clear previous selection if any
      if (this.selectedObject) {
        // Publish deselection event
        eventBus.publish('object-deselected', {
          type: this.selectedObject.userData.type,
          uri: this.selectedObject.userData.uri
        });
        
        this.selectedObject = null;
      }
      
      // Set new selection
      this.selectedObject = this.intersectedObject;
      
      // Publish selection event
      eventBus.publish('object-selected', {
        type: userData.type,
        uri: userData.uri,
        entity: userData.entity
      });
    } else {
      // Click on empty space - clear selection
      if (this.selectedObject) {
        // Publish deselection event
        eventBus.publish('object-deselected', {
          type: this.selectedObject.userData.type,
          uri: this.selectedObject.userData.uri
        });
        
        this.selectedObject = null;
      }
    }
  }
  
  /**
   * Update controls for the current frame
   * @param {number} deltaTime - Time since last frame in seconds
   * @param {THREE.Scene} scene - THREE.js scene
   */
  update(deltaTime, scene) {
    // Update movement if controls are locked
    if (this.controls.isLocked) {
      // Calculate velocity based on current movement direction
      this.velocity.x -= this.velocity.x * 10.0 * deltaTime;
      this.velocity.z -= this.velocity.z * 10.0 * deltaTime;
      this.velocity.y -= this.velocity.y * 10.0 * deltaTime;
      
      this.direction.z = Number(this.moveForward) - Number(this.moveBackward);
      this.direction.x = Number(this.moveRight) - Number(this.moveLeft);
      this.direction.y = Number(this.moveUp) - Number(this.moveDown);
      this.direction.normalize();
      
      if (this.moveForward || this.moveBackward) {
        this.velocity.z -= this.direction.z * this.movementSpeed * deltaTime;
      }
      
      if (this.moveLeft || this.moveRight) {
        this.velocity.x -= this.direction.x * this.movementSpeed * deltaTime;
      }
      
      if (this.moveUp || this.moveDown) {
        this.velocity.y += this.direction.y * this.movementSpeed * deltaTime;
      }
      
      // Move the camera
      this.controls.moveRight(-this.velocity.x);
      this.controls.moveForward(-this.velocity.z);
      this.camera.position.y += this.velocity.y;
    } else {
      // Perform raycasting for hover effects
      this.raycaster.setFromCamera(this.mouse, this.camera);
      
      // Find intersections
      const intersects = this.raycaster.intersectObjects(scene.children, true);
      
      // Reset intersected object
      if (this.intersectedObject) {
        // Handle hover out
        eventBus.publish('object-hover', {
          type: 'out',
          object: this.intersectedObject
        });
        
        this.intersectedObject = null;
      }
      
      // Set new intersected object
      if (intersects.length > 0) {
        let found = false;
        
        // Find the first object with userData.type
        for (let i = 0; i < intersects.length; i++) {
          const object = intersects[i].object;
          
          if (object.userData && object.userData.type) {
            this.intersectedObject = object;
            found = true;
            
            // Handle hover in
            eventBus.publish('object-hover', {
              type: 'in',
              object: this.intersectedObject
            });
            
            break;
          }
        }
        
        // Update cursor style
        document.body.style.cursor = found ? 'pointer' : 'auto';
      } else {
        // Reset cursor style
        document.body.style.cursor = 'auto';
      }
    }
  }
  
  /**
   * Clean up event listeners
   */
  dispose() {
    // Remove event listeners
    document.removeEventListener('keydown', this.onKeyDown);
    document.removeEventListener('keyup', this.onKeyUp);
    this.domElement.removeEventListener('click', this.onClick);
    document.removeEventListener('pointerlockchange', this.onLockChange);
    document.removeEventListener('mousemove', this.onMouseMove);
    document.removeEventListener('click', this.onObjectClick);
    
    // Dispose controls
    this.controls.dispose();
  }
}

export default Controls;

================
File: src/view/threeView/components/pipe.js
================
/**
 * Pipe component for representing relationships between classes
 * @module view/threeView/components/pipe
 */

import * as THREE from 'three';
import config from '../../../core/config.js';

class Pipe {
  /**
   * Create a new Pipe component
   * @param {Object} params - Parameters
   * @param {RelationshipEntity} params.relationshipEntity - Relationship entity to represent
   * @param {Sphere} params.sourceSphere - Source sphere
   * @param {Sphere} params.targetSphere - Target sphere
   * @param {THREE.Group} params.parent - Parent group to add pipe to
   */
  constructor({ relationshipEntity, sourceSphere, targetSphere, parent }) {
    this.relationshipEntity = relationshipEntity;
    this.sourceSphere = sourceSphere;
    this.targetSphere = targetSphere;
    this.parent = parent;
    
    // Get pipe radius from config
    this.radius = config.visualization.pipe.defaultRadius;
    
    // Create the pipe mesh
    this.createPipe();
    
    // Create label
    this.createLabel();
    
    // Add to parent
    this.parent.add(this.mesh);
  }
  
  /**
   * Create the pipe mesh
   */
  createPipe() {
    // Get positions of source and target spheres
    const sourcePos = this.sourceSphere.getWorldPosition();
    const targetPos = this.targetSphere.getWorldPosition();
    
    // Account for sphere radii - adjust start and end points
    const direction = new THREE.Vector3().subVectors(targetPos, sourcePos).normalize();
    const sourceRadius = this.sourceSphere.getRadius();
    const targetRadius = this.targetSphere.getRadius();
    
    // Adjust start and end points to be on the sphere surfaces
    const start = new THREE.Vector3().copy(sourcePos).addScaledVector(direction, sourceRadius + 0.1);
    const end = new THREE.Vector3().copy(targetPos).addScaledVector(direction, -targetRadius - 0.1);
    
    // Calculate length of the pipe
    const length = start.distanceTo(end);
    
    // Create geometry
    this.geometry = new THREE.CylinderGeometry(
      this.radius,
      this.radius,
      length,
      config.visualization.pipe.segments,
      1,
      false
    );
    
    // Rotate and position geometry
    this.geometry.translate(0, length / 2, 0);
    this.geometry.rotateX(Math.PI / 2);
    
    // Create material
    this.material = new THREE.MeshPhongMaterial({
      color: config.visualization.pipe.defaultColor,
      shininess: 30
    });
    
    // Create mesh
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    
    // Position and orient the pipe
    this.mesh.position.copy(start);
    this.mesh.lookAt(end);
    
    // Add metadata to mesh
    this.mesh.userData = {
      type: 'relationship',
      uri: this.relationshipEntity.uri.value,
      label: this.relationshipEntity.label,
      entity: this.relationshipEntity
    };
    
    // Create an arrow at the target end
    this.createArrow(end, direction);
  }
  
  /**
   * Create an arrow at the target end
   * @param {THREE.Vector3} position - Position for the arrow
   * @param {THREE.Vector3} direction - Direction the arrow points
   */
  createArrow(position, direction) {
    // Create cone geometry for arrow
    const arrowGeometry = new THREE.ConeGeometry(
      this.radius * 2,
      this.radius * 4,
      config.visualization.pipe.segments
    );
    
    // Rotate to point along pipe
    arrowGeometry.rotateX(-Math.PI / 2);
    
    // Create material
    const arrowMaterial = new THREE.MeshPhongMaterial({
      color: config.visualization.pipe.defaultColor,
      shininess: 30
    });
    
    // Create mesh
    this.arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    
    // Position arrow at the end of the pipe
    this.arrow.position.copy(position);
    this.arrow.lookAt(position.clone().sub(direction));
    
    // Add arrow to parent
    this.parent.add(this.arrow);
  }
  
  /**
   * Create a text label for the pipe
   */
  createLabel() {
    // Create a canvas for the texture
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 64;
    
    // Draw background
    context.fillStyle = 'rgba(50, 50, 50, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw border
    context.strokeStyle = 'white';
    context.lineWidth = 2;
    context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
    
    // Draw text
    context.font = '18px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(this.relationshipEntity.label, canvas.width / 2, canvas.height / 2);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Create sprite material
    const material = new THREE.SpriteMaterial({ map: texture });
    
    // Create sprite
    this.label = new THREE.Sprite(material);
    this.label.scale.set(5, 1.25, 1);
    
    // Position at middle of pipe
    const sourcePos = this.sourceSphere.getWorldPosition();
    const targetPos = this.targetSphere.getWorldPosition();
    const midpoint = new THREE.Vector3().addVectors(sourcePos, targetPos).multiplyScalar(0.5);
    
    // Elevate slightly
    midpoint.y += 1;
    
    this.label.position.copy(midpoint);
    
    // Add label to parent
    this.parent.add(this.label);
  }
  
  /**
   * Update the pipe based on sphere positions
   */
  update() {
    // Re-create pipe to update position and orientation
    this.dispose(false);
    this.createPipe();
    this.createLabel();
    
    // Update appearance based on selection state
    if (this.relationshipEntity.isSelected) {
      this.material.color.setHex(config.visualization.pipe.selectedColor);
      if (this.arrow) {
        this.arrow.material.color.setHex(config.visualization.pipe.selectedColor);
      }
    } else {
      this.material.color.setHex(config.visualization.pipe.defaultColor);
      if (this.arrow) {
        this.arrow.material.color.setHex(config.visualization.pipe.defaultColor);
      }
    }
    
    // Update visibility
    this.mesh.visible = this.relationshipEntity.isVisible;
    if (this.arrow) {
      this.arrow.visible = this.relationshipEntity.isVisible;
    }
    if (this.label) {
      this.label.visible = this.relationshipEntity.isVisible;
    }
  }
  
  /**
   * Clean up resources
   * @param {boolean} [removeFromParent=true] - Whether to remove from parent
   */
  dispose(removeFromParent = true) {
    // Remove from parent
    if (removeFromParent) {
      if (this.parent && this.mesh && this.mesh.parent === this.parent) {
        this.parent.remove(this.mesh);
      }
      
      if (this.parent && this.arrow && this.arrow.parent === this.parent) {
        this.parent.remove(this.arrow);
      }
      
      if (this.parent && this.label && this.label.parent === this.parent) {
        this.parent.remove(this.label);
      }
    }
    
    // Dispose of geometries and materials
    if (this.geometry) this.geometry.dispose();
    if (this.material) this.material.dispose();
    
    if (this.arrow) {
      if (this.arrow.geometry) this.arrow.geometry.dispose();
      if (this.arrow.material) this.arrow.material.dispose();
    }
    
    if (this.label) {
      if (this.label.material.map) this.label.material.map.dispose();
      if (this.label.material) this.label.material.dispose();
    }
  }
}

export default Pipe;

================
File: src/view/threeView/components/port.js
================
/**
 * Port component for representing interfaces on classes
 * @module view/threeView/components/port
 */

import * as THREE from 'three';
import config from '../../../core/config.js';

class Port {
  /**
   * Create a new Port component
   * @param {Object} params - Parameters
   * @param {InterfaceEntity} params.interfaceEntity - Interface entity to represent
   * @param {Sphere} params.parentSphere - Parent sphere this port belongs to
   */
  constructor({ interfaceEntity, parentSphere }) {
    this.interfaceEntity = interfaceEntity;
    this.parentSphere = parentSphere;
    
    // Get port radius from config
    this.radius = config.visualization.port.defaultRadius;
    
    // Create geometry
    this.geometry = new THREE.SphereGeometry(
      this.radius,
      config.visualization.port.segments,
      config.visualization.port.segments
    );
    
    // Create material
    this.material = new THREE.MeshPhongMaterial({
      color: config.visualization.port.defaultColor,
      shininess: 50
    });
    
    // Create mesh
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    
    // Position port on parent sphere
    this.updatePosition();
    
    // Add metadata to mesh
    this.mesh.userData = {
      type: 'interface',
      uri: this.interfaceEntity.uri.value,
      label: this.interfaceEntity.label,
      entity: this.interfaceEntity
    };
    
    // Create label
    this.createLabel();
    
    // Add to parent sphere
    this.parentSphere.mesh.add(this.mesh);
    
    // Register with parent sphere
    this.parentSphere.addPort(this);
  }
  
  /**
   * Create a text label for the port
   */
  createLabel() {
    // Create a canvas for the texture
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 128;
    canvas.height = 64;
    
    // Draw background
    context.fillStyle = 'rgba(50, 50, 50, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw border
    context.strokeStyle = 'white';
    context.lineWidth = 2;
    context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
    
    // Draw text
    context.font = '12px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(this.interfaceEntity.label, canvas.width / 2, canvas.height / 2);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Create sprite material
    const material = new THREE.SpriteMaterial({ map: texture });
    
    // Create sprite
    this.label = new THREE.Sprite(material);
    this.label.scale.set(2, 1, 1);
    
    // Position relative to port
    this.label.position.set(0, 1, 0);
    
    // Add label to mesh
    this.mesh.add(this.label);
  }
  
  /**
   * Update the position of the port on the parent sphere
   */
  updatePosition() {
    // Calculate position in spherical coordinates
    const sphereRadius = this.parentSphere.getRadius();
    const { phi, theta } = this.interfaceEntity.position;
    
    // Convert to Cartesian coordinates
    const x = sphereRadius * Math.sin(theta) * Math.cos(phi);
    const y = sphereRadius * Math.sin(theta) * Math.sin(phi);
    const z = sphereRadius * Math.cos(theta);
    
    // Set position
    this.mesh.position.set(x, y, z);
  }
  
  /**
   * Update the appearance of the port
   */
  update() {
    // Update position on sphere
    this.updatePosition();
    
    // Update appearance based on selection state
    if (this.interfaceEntity.isSelected) {
      this.material.color.setHex(config.visualization.port.selectedColor);
    } else {
      this.material.color.setHex(config.visualization.port.defaultColor);
    }
    
    // Update visibility
    this.mesh.visible = this.interfaceEntity.isVisible;
    if (this.label) {
      this.label.visible = this.interfaceEntity.isVisible;
    }
  }
  
  /**
   * Get world position of the port
   * @returns {THREE.Vector3} World position
   */
  getWorldPosition() {
    const position = new THREE.Vector3();
    this.mesh.getWorldPosition(position);
    return position;
  }
  
  /**
   * Show detailed information about the interface
   * @param {HTMLElement} infoPanel - DOM element to display information in
   */
  showDetails(infoPanel) {
    // Clear existing content
    infoPanel.innerHTML = '';
    
    // Create header
    const header = document.createElement('h3');
    header.textContent = this.interfaceEntity.label;
    infoPanel.appendChild(header);
    
    // Create interface type
    const type = document.createElement('p');
    type.textContent = `Interface URI: ${this.interfaceEntity.uri.value}`;
    infoPanel.appendChild(type);
    
    // Create methods section
    const methodsHeader = document.createElement('h4');
    methodsHeader.textContent = 'Methods:';
    infoPanel.appendChild(methodsHeader);
    
    if (this.interfaceEntity.methods.length === 0) {
      const noMethods = document.createElement('p');
      noMethods.textContent = 'No methods defined.';
      infoPanel.appendChild(noMethods);
    } else {
      const methodsList = document.createElement('ul');
      
      this.interfaceEntity.methods.forEach(method => {
        const methodItem = document.createElement('li');
        
        // Format method signature
        let signature = `${method.returnType} ${method.name}(`;
        
        if (method.parameters.length > 0) {
          signature += method.parameters.map(param => `${param.type} ${param.name}`).join(', ');
        }
        
        signature += ')';
        
        methodItem.textContent = signature;
        methodsList.appendChild(methodItem);
      });
      
      infoPanel.appendChild(methodsList);
    }
  }
  
  /**
   * Clean up resources
   */
  dispose() {
    // Remove from parent
    if (this.mesh.parent) {
      this.mesh.parent.remove(this.mesh);
    }
    
    // Dispose of geometry and material
    if (this.geometry) this.geometry.dispose();
    if (this.material) this.material.dispose();
    
    // Clean up label
    if (this.label) {
      if (this.label.material.map) this.label.material.map.dispose();
      if (this.label.material) this.label.material.dispose();
    }
  }
}

export default Port;

================
File: src/view/threeView/sphere.js
================
/**
 * Sphere component for representing classes
 * @module view/threeView/components/sphere
 */

import * as THREE from 'three';
import config from '../../../core/config.js';

class Sphere {
  /**
   * Create a new Sphere component
   * @param {Object} params - Parameters
   * @param {ClassEntity} params.classEntity - Class entity to represent
   * @param {THREE.Group} params.parent - Parent group to add sphere to
   */
  constructor({ classEntity, parent }) {
    this.classEntity = classEntity;
    this.parent = parent;
    this.ports = new Map(); // URI string -> Port
    
    // Create geometry
    const radius = classEntity.radius || config.visualization.sphere.defaultRadius;
    this.geometry = new THREE.SphereGeometry(
      radius,
      config.visualization.sphere.segments,
      config.visualization.sphere.segments
    );
    
    // Create material
    this.material = new THREE.MeshPhongMaterial({
      color: config.visualization.sphere.defaultColor,
      transparent: true,
      opacity: config.visualization.sphere.opacity,
      shininess: 30
    });
    
    // Create mesh
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.mesh.position.set(
      classEntity.position.x || 0,
      classEntity.position.y || 0,
      classEntity.position.z || 0
    );
    
    // Add metadata to mesh
    this.mesh.userData = {
      type: 'class',
      uri: classEntity.uri.value,
      label: classEntity.label,
      entity: classEntity
    };
    
    // Create label
    this.createLabel();
    
    // Add to parent
    this.parent.add(this.mesh);
  }
  
  /**
   * Create a text label for the sphere
   */
  createLabel() {
    // Create a canvas for the texture
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 128;
    
    // Draw background
    context.fillStyle = 'rgba(50, 50, 50, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw border
    context.strokeStyle = 'white';
    context.lineWidth = 2;
    context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
    
    // Draw text
    context.font = '24px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(this.classEntity.label, canvas.width / 2, canvas.height / 2);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Create sprite material
    const material = new THREE.SpriteMaterial({ map: texture });
    
    // Create sprite
    this.label = new THREE.Sprite(material);
    this.label.scale.set(5, 2.5, 1);
    
    // Position above sphere
    const yOffset = this.classEntity.radius + 2;
    this.label.position.set(0, yOffset, 0);
    
    // Add label to mesh
    this.mesh.add(this.label);
  }
  
  /**
   * Update the position and appearance of the sphere
   */
  update() {
    // Update position
    this.mesh.position.set(
      this.classEntity.position.x,
      this.classEntity.position.y,
      this.classEntity.position.z
    );
    
    // Update appearance based on selection state
    if (this.classEntity.isSelected) {
      this.material.color.setHex(config.visualization.sphere.selectedColor);
      this.material.opacity = 1.0;
    } else {
      this.material.color.setHex(config.visualization.sphere.defaultColor);
      this.material.opacity = config.visualization.sphere.opacity;
    }
  }
  
  /**
   * Add a port to this sphere
   * @param {Port} port - Port component to add
   */
  addPort(port) {
    const uriString = port.interfaceEntity.uri.value;
    this.ports.set(uriString, port);
  }
  
  /**
   * Get world position of the sphere
   * @returns {THREE.Vector3} World position
   */
  getWorldPosition() {
    const position = new THREE.Vector3();
    this.mesh.getWorldPosition(position);
    return position;
  }
  
  /**
   * Get the radius of the sphere
   * @returns {number} Sphere radius
   */
  getRadius() {
    return this.classEntity.radius;
  }
  
  /**
   * Show the sphere
   */
  show() {
    this.mesh.visible = true;
  }
  
  /**
   * Hide the sphere
   */
  hide() {
    this.mesh.visible = false;
  }
  
  /**
   * Clean up resources
   */
  dispose() {
    // Remove from parent
    if (this.parent && this.mesh.parent === this.parent) {
      this.parent.remove(this.mesh);
    }
    
    // Dispose of geometry and material
    if (this.geometry) this.geometry.dispose();
    if (this.material) this.material.dispose();
    
    // Clean up sprite
    if (this.label) {
      if (this.label.material.map) this.label.material.map.dispose();
      if (this.label.material) this.label.material.dispose();
    }
  }
}

export default Sphere;

================
File: src/view/threeView/threeView.js
================
/**
 * ThreeView renders the 3D visualization of the conceptual model
 * @module view/threeView/threeView
 */

import * as THREE from 'three';
import log from 'loglevel';
import eventBus from '../../core/eventBus.js';
import config from '../../core/config.js';
import Controls from './controls.js';
import Sphere from './components/sphere.js';
import Pipe from './components/pipe.js';
import Port from './components/port.js';

class ThreeView {
  /**
   * Create a ThreeView
   * @param {ConceptModel} conceptModel - Conceptual model
   * @param {HTMLElement} container - DOM element to render into
   */
  constructor(conceptModel, container) {
    this.conceptModel = conceptModel;
    this.container = container;
    this.log = log.getLogger('ThreeView');
    
    // Component maps
    this.spheres = new Map(); // URI string -> Sphere
    this.pipes = new Map(); // URI string -> Pipe
    this.ports = new Map(); // URI string -> Port
    
    // Initialize THREE.js
    this.initThree();
    
    // Add event listeners
    window.addEventListener('resize', this.onResize.bind(this));
    
    // Subscribe to model changes
    eventBus.subscribe('concept-model-changed', () => this.updateFromModel());
    
    // Subscribe to object selection
    eventBus.subscribe('object-selected', this.onObjectSelected.bind(this));
    eventBus.subscribe('object-deselected', this.onObjectDeselected.bind(this));
    
    // Track navigation hierarchy
    this.navigationStack = [];
    this.currentClassUri = null;
    
    // Animation loop
    this.animate = this.animate.bind(this);
    this.clock = new THREE.Clock();
    this.animate();
  }
  
  /**
   * Initialize THREE.js renderer, scene, and camera
   */
  initThree() {
    // Create renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.container.appendChild(this.renderer.domElement);
    
    // Create scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x111133);
    
    // Create camera
    this.camera = new THREE.PerspectiveCamera(
      config.visualization.camera.fov,
      this.container.clientWidth / this.container.clientHeight,
      config.visualization.camera.near,
      config.visualization.camera.far
    );
    this.camera.position.set(
      config.visualization.camera.position.x,
      config.visualization.camera.position.y,
      config.visualization.camera.position.z
    );
    
    // Create controls
    this.controls = new Controls(this.camera, this.renderer.domElement);
    
    // Add lights
    this.addLights();
    
    // Create object groups
    this.spheresGroup = new THREE.Group();
    this.pipesGroup = new THREE.Group();
    this.scene.add(this.spheresGroup);
    this.scene.add(this.pipesGroup);
    
    this.log.debug('THREE.js initialized');
  }
  
  /**
   * Add lights to the scene
   */
  addLights() {
    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0x404040);
    this.scene.add(ambientLight);
    
    // Add directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1);
    this.scene.add(directionalLight);
    
    // Add point lights
    const pointLight1 = new THREE.PointLight(0xffffff, 0.5);
    pointLight1.position.set(50, 50, 50);
    this.scene.add(pointLight1);
    
    const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
    pointLight2.position.set(-50, -50, -50);
    this.scene.add(pointLight2);
  }
  
  /**
   * Update the view from the conceptual model
   */
  updateFromModel() {
    this.log.info('Updating ThreeView from conceptual model');
    
    // Clear current visualization
    this.clearVisualization();
    
    // If we're showing a specific class's internals
    if (this.currentClassUri) {
      this.renderClassInternals(this.currentClassUri);
    } else {
      // Render all top-level classes
      this.renderClasses();
      
      // Render relationships between classes
      this.renderRelationships();
      
      // Render interfaces on classes
      this.renderInterfaces();
    }
  }
  
  /**
   * Clear the current visualization
   */
  clearVisualization() {
    // Dispose and clear spheres
    for (const sphere of this.spheres.values()) {
      sphere.dispose();
    }
    this.spheres.clear();
    
    // Dispose and clear pipes
    for (const pipe of this.pipes.values()) {
      pipe.dispose();
    }
    this.pipes.clear();
    
    // Dispose and clear ports
    for (const port of this.ports.values()) {
      port.dispose();
    }
    this.ports.clear();
  }
  
  /**
   * Render all classes in the conceptual model
   */
  renderClasses() {
    for (const classEntity of this.conceptModel.classes.values()) {
      this.renderClass(classEntity);
    }
  }
  
  /**
   * Render a single class entity
   * @param {ClassEntity} classEntity - Class entity to render
   * @returns {Sphere} The created sphere component
   */
  renderClass(classEntity) {
    const uriString = classEntity.uri.value;
    
    // Skip if we already have this class
    if (this.spheres.has(uriString)) {
      return this.spheres.get(uriString);
    }
    
    // Create sphere for the class
    const sphere = new Sphere({
      classEntity,
      parent: this.spheresGroup
    });
    
    // Store the sphere
    this.spheres.set(uriString, sphere);
    
    this.log.debug(`Rendered class: ${classEntity.label} (${uriString})`);
    
    return sphere;
  }
  
  /**
   * Render relationships between classes
   */
  renderRelationships() {
    for (const relationshipEntity of this.conceptModel.relationships.values()) {
      this.renderRelationship(relationshipEntity);
    }
  }
  
  /**
   * Render a single relationship entity
   * @param {RelationshipEntity} relationshipEntity - Relationship entity to render
   * @returns {Pipe} The created pipe component
   */
  renderRelationship(relationshipEntity) {
    const uriString = relationshipEntity.uri.value;
    
    // Skip if we already have this relationship
    if (this.pipes.has(uriString)) {
      return this.pipes.get(uriString);
    }
    
    const sourceUriString = relationshipEntity.sourceClassUri.value;
    const targetUriString = relationshipEntity.targetClassUri.value;
    
    // Skip if we don't have the source or target class
    if (!this.spheres.has(sourceUriString) || !this.spheres.has(targetUriString)) {
      this.log.warn(`Cannot render relationship ${uriString}: missing source or target class`);
      return null;
    }
    
    // Get source and target spheres
    const sourceSphere = this.spheres.get(sourceUriString);
    const targetSphere = this.spheres.get(targetUriString);
    
    // Create pipe for the relationship
    const pipe = new Pipe({
      relationshipEntity,
      sourceSphere,
      targetSphere,
      parent: this.pipesGroup
    });
    
    // Store the pipe
    this.pipes.set(uriString, pipe);
    
    this.log.debug(`Rendered relationship: ${relationshipEntity.label} (${uriString})`);
    
    return pipe;
  }
  
  /**
   * Render interfaces on classes
   */
  renderInterfaces() {
    for (const interfaceEntity of this.conceptModel.interfaces.values()) {
      this.renderInterface(interfaceEntity);
    }
  }
  
  /**
   * Render a single interface entity
   * @param {InterfaceEntity} interfaceEntity - Interface entity to render
   * @returns {Port} The created port component
   */
  renderInterface(interfaceEntity) {
    const uriString = interfaceEntity.uri.value;
    
    // Skip if we already have this interface
    if (this.ports.has(uriString)) {
      return this.ports.get(uriString);
    }
    
    const classUriString = interfaceEntity.classUri.value;
    
    // Skip if we don't have the class
    if (!this.spheres.has(classUriString)) {
      this.log.warn(`Cannot render interface ${uriString}: missing class ${classUriString}`);
      return null;
    }
    
    // Get parent sphere
    const parentSphere = this.spheres.get(classUriString);
    
    // Create port for the interface
    const port = new Port({
      interfaceEntity,
      parentSphere
    });
    
    // Store the port
    this.ports.set(uriString, port);
    
    this.log.debug(`Rendered interface: ${interfaceEntity.label} (${uriString})`);
    
    return port;
  }
  
  /**
   * Render the internals of a class
   * @param {string} classUriString - URI of the class to render internals for
   */
  renderClassInternals(classUriString) {
    const classEntity = this.conceptModel.getClass(classUriString);
    
    if (!classEntity) {
      this.log.error(`Cannot render internals for unknown class ${classUriString}`);
      return;
    }
    
    this.log.info(`Rendering internals for class ${classEntity.label} (${classUriString})`);
    
    // Render subclasses
    for (const subclassUri of classEntity.subclasses) {
      const subclassEntity = this.conceptModel.getClass(subclassUri.value);
      
      if (subclassEntity) {
        this.renderClass(subclassEntity);
      }
    }
    
    // Render relationships between subclasses
    for (const relationshipEntity of this.conceptModel.relationships.values()) {
      const sourceUriString = relationshipEntity.sourceClassUri.value;
      const targetUriString = relationshipEntity.targetClassUri.value;
      
      // Only render relationships between subclasses
      if (this.spheres.has(sourceUriString) && this.spheres.has(targetUriString)) {
        this.renderRelationship(relationshipEntity);
      }
    }
    
    // Render interfaces on subclasses
    for (const interfaceEntity of this.conceptModel.interfaces.values()) {
      const interfaceClassUriString = interfaceEntity.classUri.value;
      
      // Only render interfaces on subclasses
      if (this.spheres.has(interfaceClassUriString)) {
        this.renderInterface(interfaceEntity);
      }
    }
  }
  
  /**
   * Navigate into a class sphere to view its internals
   * @param {string} classUriString - URI of the class to enter
   */
  enterClass(classUriString) {
    const classEntity = this.conceptModel.getClass(classUriString);
    
    if (!classEntity) {
      this.log.error(`Cannot enter unknown class ${classUriString}`);
      return;
    }
    
    // Push current state to navigation stack
    this.navigationStack.push({
      classUri: this.currentClassUri,
      cameraPosition: this.camera.position.clone(),
      cameraRotation: this.camera.rotation.clone()
    });
    
    // Set current class
    this.currentClassUri = classUriString;
    
    // Reset camera position
    this.camera.position.set(0, 0, 15);
    this.camera.rotation.set(0, 0, 0);
    
    // Update view
    this.updateFromModel();
    
    this.log.info(`Entered class ${classEntity.label} (${classUriString})`);
    eventBus.publish('class-entered', { classEntity });
  }
  
  /**
   * Navigate out of the current class
   */
  exitClass() {
    if (this.navigationStack.length === 0) {
      this.log.warn('Cannot exit class: navigation stack is empty');
      return;
    }
    
    // Pop state from navigation stack
    const state = this.navigationStack.pop();
    
    // Get the class we're exiting from
    const exitingClassEntity = this.conceptModel.getClass(this.currentClassUri);
    
    // Restore state
    this.currentClassUri = state.classUri;
    this.camera.position.copy(state.cameraPosition);
    this.camera.rotation.copy(state.cameraRotation);
    
    // Update view
    this.updateFromModel();
    
    this.log.info(`Exited class ${exitingClassEntity?.label || 'unknown'}`);
    eventBus.publish('class-exited', { classEntity: exitingClassEntity });
  }
  
  /**
   * Handle object selection
   * @param {Object} data - Selection data
   * @param {string} data.type - Object type (class, relationship, interface)
   * @param {string} data.uri - Object URI
   * @param {Object} data.entity - Object entity
   */
  onObjectSelected(data) {
    const { type, uri } = data;
    
    if (type === 'class') {
      const classEntity = this.conceptModel.getClass(uri);
      
      if (classEntity) {
        classEntity.isSelected = true;
        
        // Update sphere appearance
        const sphere = this.spheres.get(uri);
        if (sphere) {
          sphere.update();
        }
      }
    } else if (type === 'relationship') {
      const relationshipEntity = this.conceptModel.getRelationship(uri);
      
      if (relationshipEntity) {
        relationshipEntity.isSelected = true;
        
        // Update pipe appearance
        const pipe = this.pipes.get(uri);
        if (pipe) {
          pipe.update();
        }
      }
    } else if (type === 'interface') {
      const interfaceEntity = this.conceptModel.getInterface(uri);
      
      if (interfaceEntity) {
        interfaceEntity.isSelected = true;
        
        // Update port appearance
        const port = this.ports.get(uri);
        if (port) {
          port.update();
        }
      }
    }
  }
  
  /**
   * Handle object deselection
   * @param {Object} data - Deselection data
   * @param {string} data.type - Object type (class, relationship, interface)
   * @param {string} data.uri - Object URI
   */
  onObjectDeselected(data) {
    const { type, uri } = data;
    
    if (type === 'class') {
      const classEntity = this.conceptModel.getClass(uri);
      
      if (classEntity) {
        classEntity.isSelected = false;
        
        // Update sphere appearance
        const sphere = this.spheres.get(uri);
        if (sphere) {
          sphere.update();
        }
      }
    } else if (type === 'relationship') {
      const relationshipEntity = this.conceptModel.getRelationship(uri);
      
      if (relationshipEntity) {
        relationshipEntity.isSelected = false;
        
        // Update pipe appearance
        const pipe = this.pipes.get(uri);
        if (pipe) {
          pipe.update();
        }
      }
    } else if (type === 'interface') {
      const interfaceEntity = this.conceptModel.getInterface(uri);
      
      if (interfaceEntity) {
        interfaceEntity.isSelected = false;
        
        // Update port appearance
        const port = this.ports.get(uri);
        if (port) {
          port.update();
        }
      }
    }
  }
  
  /**
   * Handle window resize
   */
  onResize() {
    // Update camera aspect ratio
    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
    this.camera.updateProjectionMatrix();
    
    // Update renderer size
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
  }
  
  /**
   * Animation loop
   */
  animate() {
    requestAnimationFrame(this.animate);
    
    // Get delta time
    const deltaTime = this.clock.getDelta();
    
    // Update controls
    this.controls.update(deltaTime, this.scene);
    
    // Render scene
    this.renderer.render(this.scene, this.camera);
  }
  
  /**
   * Clean up resources
   */
  dispose() {
    // Stop animation loop
    cancelAnimationFrame(this.animate);
    
    // Remove event listeners
    window.removeEventListener('resize', this.onResize);
    
    // Dispose of controls
    this.controls.dispose();
    
    // Dispose of components
    this.clearVisualization();
    
    // Dispose of THREE.js resources
    this.renderer.dispose();
    
    // Remove renderer from DOM
    if (this.renderer.domElement.parentNode) {
      this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
    }
  }
}

export default ThreeView;

================
File: src/app.js
================
/**
 * Main UVE application entry point
 * @module app
 */

import log from 'loglevel';
import eventBus from './core/eventBus.js';
import config from './core/config.js';
import RDFModel from './model/rdfModel.js';
import ConceptModel from './model/conceptModel.js';
import ThreeView from './view/threeView/threeView.js';
import RDFFileView from './view/rdfView/rdfFileView.js';
import createFOAFExample from './examples/foafExample.js';

/**
 * Main application class
 */
class App {
  /**
   * Create UVE application
   */
  constructor() {
    // Configure logging
    log.setLevel(config.system.logLevel);
    this.log = log.getLogger('App');
    
    // Initialize model
    this.initModel();
    
    // Initialize views
    this.initViews();
    
    // Load example data
    this.loadExampleData();
    
    // Subscribe to events
    this.setupEvents();
    
    this.log.info('UVE application initialized');
  }
  
  /**
   * Initialize the data model
   */
  initModel() {
    this.log.debug('Initializing model');
    
    // Create RDF model
    this.rdfModel = new RDFModel();
    
    // Create concept model
    this.conceptModel = new ConceptModel(this.rdfModel);
  }
  
  /**
   * Initialize the views
   */
  initViews() {
    this.log.debug('Initializing views');
    
    // Find view containers
    const threeViewContainer = document.getElementById('three-view-container');
    const rdfViewContainer = document.getElementById('rdf-view-container');
    
    if (!threeViewContainer || !rdfViewContainer) {
      this.log.error('View containers not found in DOM');
      throw new Error('View containers not found');
    }
    
    // Create Three.js view
    this.threeView = new ThreeView(this.conceptModel, threeViewContainer);
    
    // Create RDF file view
    this.rdfView = new RDFFileView(this.rdfModel, rdfViewContainer);
  }
  
  /**
   * Load example data
   */
  loadExampleData() {
    this.log.info('Loading example FOAF data');
    
    try {
      // Create FOAF example dataset
      const dataset = createFOAFExample();
      
      // Add to RDF model
      this.rdfModel.dataset.deleteMatches();
      this.rdfModel.dataset.addAll(dataset);
      
      // Notify of change
      eventBus.publish('rdf-model-changed', { source: 'example' });
      
      this.log.info(`Loaded ${dataset.size} triples from FOAF example`);
    } catch (error) {
      this.log.error('Failed to load example data:', error);
    }
  }
  
  /**
   * Set up event handlers
   */
  setupEvents() {
    // Handle class enter/exit
    eventBus.subscribe('object-selected', data => {
      if (data.type === 'class' && data.entity.subclasses.length > 0) {
        // If the class has subclasses, show an "Enter Class" button
        this.showEnterClassButton(data.uri, data.entity.label);
      } else {
        this.hideEnterClassButton();
      }
    });
    
    eventBus.subscribe('object-deselected', () => {
      this.hideEnterClassButton();
    });
    
    // Create and add enter class button to DOM (hidden initially)
    this.enterClassButton = document.createElement('button');
    this.enterClassButton.id = 'enter-class-button';
    this.enterClassButton.className = 'enter-class-button hidden';
    this.enterClassButton.textContent = 'Enter Class';
    document.body.appendChild(this.enterClassButton);
    
    // Create and add exit class button to DOM (hidden initially)
    this.exitClassButton = document.createElement('button');
    this.exitClassButton.id = 'exit-class-button';
    this.exitClassButton.className = 'exit-class-button hidden';
    this.exitClassButton.textContent = 'Exit Class';
    this.exitClassButton.addEventListener('click', () => {
      this.threeView.exitClass();
      this.exitClassButton.classList.add('hidden');
    });
    document.body.appendChild(this.exitClassButton);
  }
  
  /**
   * Show the enter class button for a specific class
   * @param {string} classUri - URI of the class
   * @param {string} label - Label of the class
   */
  showEnterClassButton(classUri, label) {
    this.enterClassButton.textContent = `Enter ${label}`;
    this.enterClassButton.classList.remove('hidden');
    
    // Remove any existing click event
    const newButton = this.enterClassButton.cloneNode(true);
    this.enterClassButton.parentNode.replaceChild(newButton, this.enterClassButton);
    this.enterClassButton = newButton;
    
    // Add click event for this specific class
    this.enterClassButton.addEventListener('click', () => {
      this.threeView.enterClass(classUri);
      this.enterClassButton.classList.add('hidden');
      this.exitClassButton.classList.remove('hidden');
    });
  }
  
  /**
   * Hide the enter class button
   */
  hideEnterClassButton() {
    this.enterClassButton.classList.add('hidden');
  }
}

// Start the application when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.app = new App();
});

export default App;

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: jsdoc.config.json
================
{
  "source": {
    "include": ["src", "README.md"],
    "exclude": ["node_modules"]
  },
  "opts": {
    "destination": "./docs/generated",
    "recurse": true,
    "template": "node_modules/docdash"
  },
  "plugins": ["plugins/markdown"],
  "templates": {
    "cleverLinks": true,
    "monospaceLinks": false
  },
  "docdash": {
    "static": true,
    "sort": true
  }
}

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "uve",
  "version": "0.1.0",
  "description": "Universal Virtual Environment - 3D visualization of conceptual space using Three.js and RDF",
  "main": "src/app.js",
  "type": "module",
  "scripts": {
    "rp": "repomix -c repomix.config.json .",
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "jasmine"
  },
  "keywords": [
    "rdf",
    "threejs",
    "visualization",
    "semantic-web",
    "3d"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@rdfjs/formats": "^4.0.1",
    "@rdfjs/formats-common": "^3.1.0",
    "@rdfjs/namespace": "^2.0.1",
    "grapoi": "^1.1.3",
    "loglevel": "^1.8.1",
    "rdf-ext": "^2.5.0",
    "rdf-utils-fs": "^2.3.0",
    "three": "^0.158.0"
  },
  "devDependencies": {
    "chai": "^4.3.7",
    "jasmine": "^5.1.0",
    "vite": "^4.5.0"
  }
}

================
File: README.md
================
# UVE - Universal Virtual Environment

A 3D visualization of conceptual space using Three.js and RDF/OWL models.

## Overview

UVE renders conceptual space in 3D, where:
- Classes are represented as spheres
- Relationships between classes are visualized as labeled pipes
- Interfaces appear as ports on sphere surfaces
- Navigation uses first-person camera with mouse/arrow key controls
- Hierarchical visualization with nested spaces (entering a class sphere reveals its subclasses)

The data model is represented using RDF/OWL models and accessed via RDF-Ext and Grapoi libraries.

## Features

- 3D visualization of class hierarchies
- Interactive navigation through conceptual space
- RDF data editing with live visualization updates
- Support for various RDF formats (Turtle, N-Triples, JSON-LD, etc.)
- FOAF vocabulary example with 5 friends

## Architecture

UVE follows a Model-View architecture with pub-sub messaging:
- **Core**: EventBus for pub-sub messaging and configuration
- **Model**: RDF dataset management and conceptual model transformation
- **Views**: Three.js 3D visualization and RDF file editing
- **Utilities**: Helper functions for various tasks

## Getting Started

### Prerequisites

- Node.js (v14 or later)
- npm or yarn

### Installation

1. Clone the repository
   ```
   git clone https://github.com/yourusername/uve.git
   cd uve
   ```

2. Install dependencies
   ```
   npm install
   ```

3. Run the development server
   ```
   npm run dev
   ```

4. Open your browser at `http://localhost:5173`

### Building for Production

```
npm run build
```

The built files will be in the `dist` directory.

## Usage

### Navigation

- Click on the 3D view to enable navigation mode
- Use WASD or arrow keys to move
- Use Q/E to move up/down
- Move the mouse to look around
- Press ESC to exit navigation mode

### Interaction

- Click on objects to select them
- Click "Enter Class" to navigate into a class sphere
- Click "Exit Class" to navigate back out
- Use the RDF view to edit the data model

## Development

### Code Structure

```
src/
├── core/               # Core system components
│   ├── eventBus.js     # Pub-sub messaging system
│   └── config.js       # System configuration
├── model/              # Data model components
│   ├── rdfModel.js     # RDF dataset management
│   ├── conceptModel.js # Conceptual model transformation
│   └── entityTypes/    # Domain entity definitions
├── view/               # View components
│   ├── rdfView/        # RDF editing view
│   └── threeView/      # Three.js visualization
├── examples/           # Example data models
│   └── foafExample.js  # FOAF example with 5 friends
├── util/               # Utility functions
│   └── idGenerator.js  # Unique ID generation
└── styles/             # CSS styles
    └── main.css        # Main styling
```

### Testing

Run the tests with:

```
npm test
```

## License

[MIT](LICENSE)

================
File: repomix.config.json
================
{
    "output": {
        "filePath": "./repomix-uve.md",
        "headerText": "UVE repo",
        "removeComments": false
    },
    "include": [
        "**/*"
    ],
    "ignore": {
        "useDefaultPatterns": false,
        "customPatterns": [
            ".git",
            "package-lock.json",
            "data",
            "docs",
            ".nyc_output",
            ".env",
            "**/_*",
            "node_modules",
            "*.log",
            "**/*repomix*.txt",
            "**/*repomix*.md",
            "**/*.html",
            "**/data/*",
            "**/*copy*.js",
            "**/conversations.json"
        ]
    }
}

================
File: vite.config.js
================
import { defineConfig } from 'vite';

export default defineConfig({
  server: {
    open: true
  },
  build: {
    outDir: 'dist',
    assetsDir: 'assets'
  },
  resolve: {
    alias: {
      '@': '/src'
    }
  }
});

================
File: webpack.config.js
================
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');

module.exports = {
  mode: 'development',
  entry: './src/js/app.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  devServer: {
    static: './dist',
    hot: true,
    open: true,
    port: 9000
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      filename: 'index.html',
    }),
    new CopyWebpackPlugin({
      patterns: [
        { from: 'src/assets', to: 'assets', noErrorOnMissing: true }
      ],
    }),
  ],
};
