This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-11T09:48:19.110Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------
User Provided Header:
-----------------------
UVE repo

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
spec/
  core/
    eventBusSpec.js
  support/
    jasmine.json
  util/
    fsStorageService.spec.js
    mockFS.spec.js
    storageManage.spec.js
src/
  core/
    config.js
    eventBus.js
  examples/
    foafExample.js
  model/
    entityTypes/
      classEntity.js
      interfaceEntity.js
      relationshipEntity.js
    conceptModel.js
    rdfModel.js
  styles/
    main.css
  util/
    fsStorageService.js
    idGenerator.js
    initFs.js
    mockFs.js
    sparqlStorageService.js
    storageManager.js
    storageService.js
  view/
    rdfView/
      rdfFileView.js
    threeView/
      components/
        controls.js
        pipe.js
        port.js
        sphere.js
      threeView.js
  app.js
  index.js
.gitignore
jsdoc.config.json
LICENSE
package.json
README.md
repomix.config.json
vite.config.js
webpack.config.js

================================================================
Files
================================================================

================
File: spec/core/eventBusSpec.js
================
/**
 * Tests for the EventBus module
 */

import eventBus from '../../src/core/eventBus.js';

describe('EventBus', () => {
  // Clear all subscribers before each test
  beforeEach(() => {
    eventBus.clear();
  });

  // Test subscribe and publish functionality
  it('should allow subscribing to events', () => {
    const callback = jasmine.createSpy('callback');
    eventBus.subscribe('test-event', callback);
    
    eventBus.publish('test-event', { data: 'test' });
    expect(callback).toHaveBeenCalledWith({ data: 'test' });
  });
  
  // Test multiple subscribers
  it('should call multiple subscribers for the same event', () => {
    const callback1 = jasmine.createSpy('callback1');
    const callback2 = jasmine.createSpy('callback2');
    
    eventBus.subscribe('test-event', callback1);
    eventBus.subscribe('test-event', callback2);
    
    eventBus.publish('test-event', { data: 'test' });
    
    expect(callback1).toHaveBeenCalledWith({ data: 'test' });
    expect(callback2).toHaveBeenCalledWith({ data: 'test' });
  });
  
  // Test unsubscribe functionality
  it('should allow unsubscribing from events', () => {
    const callback = jasmine.createSpy('callback');
    const unsubscribe = eventBus.subscribe('test-event', callback);
    
    // First publication should trigger callback
    eventBus.publish('test-event', { data: 'test1' });
    expect(callback).toHaveBeenCalledWith({ data: 'test1' });
    
    // Unsubscribe
    unsubscribe();
    
    // Reset call count
    callback.calls.reset();
    
    // Second publication should not trigger callback
    eventBus.publish('test-event', { data: 'test2' });
    expect(callback).not.toHaveBeenCalled();
  });
  
  // Test error handling in callbacks
  it('should handle errors in subscribers', () => {
    const goodCallback = jasmine.createSpy('goodCallback');
    const badCallback = jasmine.createSpy('badCallback').and.throwError('Test error');
    
    eventBus.subscribe('test-event', badCallback);
    eventBus.subscribe('test-event', goodCallback);
    
    // This should not throw, despite the error in badCallback
    expect(() => {
      eventBus.publish('test-event', { data: 'test' });
    }).not.toThrow();
    
    // The good callback should still be called
    expect(goodCallback).toHaveBeenCalledWith({ data: 'test' });
  });
  
  // Test clearing all subscribers
  it('should allow clearing all subscribers', () => {
    const callback1 = jasmine.createSpy('callback1');
    const callback2 = jasmine.createSpy('callback2');
    
    eventBus.subscribe('event1', callback1);
    eventBus.subscribe('event2', callback2);
    
    eventBus.clear();
    
    eventBus.publish('event1', { data: 'test' });
    eventBus.publish('event2', { data: 'test' });
    
    expect(callback1).not.toHaveBeenCalled();
    expect(callback2).not.toHaveBeenCalled();
  });
  
  // Test clearing specific event subscribers
  it('should allow clearing subscribers for a specific event', () => {
    const callback1 = jasmine.createSpy('callback1');
    const callback2 = jasmine.createSpy('callback2');
    
    eventBus.subscribe('event1', callback1);
    eventBus.subscribe('event2', callback2);
    
    eventBus.clear('event1');
    
    eventBus.publish('event1', { data: 'test' });
    eventBus.publish('event2', { data: 'test' });
    
    expect(callback1).not.toHaveBeenCalled();
    expect(callback2).toHaveBeenCalledWith({ data: 'test' });
  });
});

================
File: spec/support/jasmine.json
================
{
  "spec_dir": "spec",
  "spec_files": [
    "**/*[sS]pec.?(m)js"
  ],
  "helpers": [
    "helpers/**/*.?(m)js"
  ],
  "env": {
    "stopSpecOnExpectationFailure": false,
    "random": true
  }
}

================
File: spec/util/fsStorageService.spec.js
================
/**
 * Tests for the FS storage service
 */
import FSStorageService from '../../src/util/fsStorageService.js';
import mockFs from '../../src/util/mockFs.js';

describe('FSStorageService', () => {
    let storage;

    // Set up storage service and reset mockFs before each test
    beforeEach(() => {
        mockFs.reset();
        storage = new FSStorageService(mockFs, 'test-data');
    });

    it('should write and read data by ID', async () => {
        const testId = 'document1.json';
        const testData = { title: 'Test Document', content: 'Hello world' };

        await storage.write(testId, testData);
        const result = await storage.read(testId, { encoding: 'utf8' });

        // Convert result back to object for comparison
        const parsedResult = JSON.parse(result);
        expect(parsedResult).toEqual(testData);
    });

    it('should handle binary data', async () => {
        const testId = 'binary.dat';
        const testData = new Uint8Array([1, 2, 3, 4, 5]);

        await storage.write(testId, testData);
        const result = await storage.read(testId);

        expect(result instanceof Uint8Array).toBe(true);
        expect(Array.from(result)).toEqual([1, 2, 3, 4, 5]);
    });

    it('should delete data by ID', async () => {
        const testId = 'to-delete.json';
        const testData = { delete: true };

        await storage.write(testId, testData);

        // Verify it exists
        const exists = await mockFs.exists(storage._getPath(testId));
        expect(exists).toBe(true);

        // Delete it
        await storage.delete(testId);

        // Verify it's gone
        const existsAfterDelete = await mockFs.exists(storage._getPath(testId));
        expect(existsAfterDelete).toBe(false);
    });

    it('should list resources', async () => {
        // Create test data in various paths
        await storage.write('file1.json', { id: 1 });
        await storage.write('file2.json', { id: 2 });
        await storage.write('dir1/file3.json', { id: 3 });
        await storage.write('dir1/file4.json', { id: 4 });

        // List root resources
        const rootFiles = await storage.list();
        expect(rootFiles.length).toBe(2);
        expect(rootFiles).toContain('file1.json');
        expect(rootFiles).toContain('file2.json');

        // List subdirectory resources
        const subFiles = await storage.list('dir1');
        expect(subFiles.length).toBe(2);
        expect(subFiles).toContain('dir1/file3.json');
        expect(subFiles).toContain('dir1/file4.json');
    });

    it('should query data with filters', async () => {
        // Create test data
        await storage.write('doc1.json', { type: 'article', title: 'Article 1' });
        await storage.write('doc2.json', { type: 'article', title: 'Article 2' });
        await storage.write('doc3.json', { type: 'note', title: 'Note 1' });

        // Query by type
        const articles = await storage.query({ type: 'article' });
        expect(articles.length).toBe(2);
        expect(articles[0].data.title).toBe('Article 1');
        expect(articles[1].data.title).toBe('Article 2');

        // Query by type and title
        const specificArticle = await storage.query({ type: 'article', title: 'Article 2' });
        expect(specificArticle.length).toBe(1);
        expect(specificArticle[0].data.title).toBe('Article 2');

        // Query that returns no results
        const nonexistent = await storage.query({ type: 'nonexistent' });
        expect(nonexistent.length).toBe(0);
    });

    it('should handle paths with proper normalization', async () => {
        // Test with trailing slash in base path
        const storage1 = new FSStorageService(mockFs, 'base/');
        await storage1.write('test.json', { data: 'test' });

        // Test without trailing slash in base path
        const storage2 = new FSStorageService(mockFs, 'base');
        const result = await storage2.read('test.json', { encoding: 'utf8' });

        expect(JSON.parse(result)).toEqual({ data: 'test' });
    });
});

================
File: spec/util/mockFS.spec.js
================
/**
 * Tests for the mock filesystem module
 */
import mockFs from '../../src/util/mockFs.js';

describe('mockFs', () => {
    // Reset mockFs before each test
    beforeEach(() => {
        mockFs.reset();
    });

    it('should write and read a file', async () => {
        const testPath = 'test.txt';
        const testContent = 'Hello, world!';

        await mockFs.writeFile(testPath, testContent);
        const content = await mockFs.readFile(testPath, { encoding: 'utf8' });

        expect(content).toBe(testContent);
    });

    it('should handle binary data with Uint8Array', async () => {
        const testPath = 'binary.dat';
        const testData = new Uint8Array([1, 2, 3, 4, 5]);

        await mockFs.writeFile(testPath, testData);
        const data = await mockFs.readFile(testPath);

        // Since we're simulating binary, check if the types match
        expect(data instanceof Uint8Array).toBe(true);
        // Convert Uint8Array to Array for easier comparison
        expect(Array.from(data)).toEqual([1, 2, 3, 4, 5]);
    });

    it('should throw an error when reading a non-existent file', async () => {
        try {
            await mockFs.readFile('non-existent.txt');
            // If we get here, the test fails
            fail('Expected an error to be thrown');
        } catch (error) {
            expect(error.message).toContain('ENOENT: no such file or directory');
        }
    });

    it('should delete a file', async () => {
        const testPath = 'to-delete.txt';
        await mockFs.writeFile(testPath, 'Delete me');

        // File exists before deletion
        expect(await mockFs.exists(testPath)).toBe(true);

        await mockFs.unlink(testPath);

        // File doesn't exist after deletion
        expect(await mockFs.exists(testPath)).toBe(false);
    });

    it('should list files in a directory', async () => {
        // Create some files in different directories
        await mockFs.writeFile('dir1/file1.txt', 'Content 1');
        await mockFs.writeFile('dir1/file2.txt', 'Content 2');
        await mockFs.writeFile('dir2/file3.txt', 'Content 3');

        const dir1Files = await mockFs.readdir('dir1');

        expect(dir1Files.length).toBe(2);
        expect(dir1Files).toContain('file1.txt');
        expect(dir1Files).toContain('file2.txt');

        const dir2Files = await mockFs.readdir('dir2');

        expect(dir2Files.length).toBe(1);
        expect(dir2Files).toContain('file3.txt');
    });

    it('should identify directories', async () => {
        await mockFs.writeFile('dir1/file1.txt', 'Content 1');

        expect(await mockFs.isDirectory('dir1')).toBe(true);
        expect(await mockFs.isDirectory('dir1/file1.txt')).toBe(false);
        expect(await mockFs.isDirectory('nonexistent')).toBe(false);
    });

    it('should reset all file storage', async () => {
        await mockFs.writeFile('file1.txt', 'Content 1');
        await mockFs.writeFile('file2.txt', 'Content 2');

        expect(await mockFs.exists('file1.txt')).toBe(true);

        mockFs.reset();

        expect(await mockFs.exists('file1.txt')).toBe(false);
        expect(await mockFs.exists('file2.txt')).toBe(false);
    });
});

================
File: spec/util/storageManage.spec.js
================
/**
 * Tests for the storage manager
 */
import storageManager from '../../src/util/storageManager.js';
import mockFs from '../../src/util/mockFs.js';
import FSStorageService from '../../src/util/fsStorageService.js';
import SPARQLStorageService from '../../src/util/sparqlStorageService.js';

describe('StorageManager', () => {
    // Reset mockFs before each test
    beforeEach(() => {
        mockFs.reset();

        // Reset storageManager to default state
        storageManager.storageServices.clear();
        storageManager.defaultService = null;
        storageManager.registerService('default', new FSStorageService(mockFs));
        storageManager.setDefaultService('default');
    });

    it('should provide a window.fs API for backward compatibility', () => {
        expect(typeof window.fs).toBe('object');
        expect(typeof window.fs.readFile).toBe('function');
        expect(typeof window.fs.writeFile).toBe('function');
        expect(typeof window.fs.unlink).toBe('function');
        expect(typeof window.fs.exists).toBe('function');
        expect(typeof window.fs.readdir).toBe('function');
    });

    it('should write and read files through the fs API', async () => {
        const testPath = 'test.txt';
        const testContent = 'Hello, world!';

        await window.fs.writeFile(testPath, testContent);
        const content = await window.fs.readFile(testPath, { encoding: 'utf8' });

        expect(content).toBe(testContent);
    });

    it('should allow registering multiple storage services', async () => {
        // Create a mock SPARQL service (no actual HTTP requests)
        const mockSparqlService = jasmine.createSpyObj('SPARQLStorageService', [
            'read', 'write', 'delete', 'list', 'query'
        ]);

        mockSparqlService.read.and.returnValue(Promise.resolve('test data'));

        // Register the mock service
        storageManager.registerService('sparql', mockSparqlService);

        // Test with default service (fs)
        await storageManager.writeFile('fs-test.txt', 'fs data');
        const fsData = await storageManager.readFile('fs-test.txt', { encoding: 'utf8' });
        expect(fsData).toBe('fs data');

        // Switch to SPARQL service
        storageManager.setDefaultService('sparql');

        // Read from SPARQL service
        const sparqlData = await storageManager.readFile('sparql-test.txt');
        expect(sparqlData).toBe('test data');
        expect(mockSparqlService.read).toHaveBeenCalledWith('sparql-test.txt', jasmine.any(Object));
    });

    it('should handle errors properly', async () => {
        // Try to read a non-existent file
        try {
            await storageManager.readFile('non-existent.txt');
            fail('Expected an error to be thrown');
        } catch (error) {
            expect(error.message).toContain('ENOENT: no such file or directory');
        }

        // Verify exists returns false for non-existent files
        const exists = await storageManager.exists('non-existent.txt');
        expect(exists).toBe(false);
    });

    it('should support querying data', async () => {
        // Create some test data
        await storageManager.writeFile('doc1.json', JSON.stringify({
            type: 'article',
            title: 'Test Article'
        }));

        await storageManager.writeFile('doc2.json', JSON.stringify({
            type: 'note',
            title: 'Test Note'
        }));

        // Query for articles
        const articles = await storageManager.query({ type: 'article' });

        expect(articles.length).toBe(1);
        expect(articles[0].data.title).toBe('Test Article');

        // Query with non-matching filter
        const nonexistent = await storageManager.query({ type: 'nonexistent' });
        expect(nonexistent.length).toBe(0);
    });
});

================
File: src/core/config.js
================
/**
 * System configuration for UVE
 * Contains default settings and constants
 * @module core/config
 */

const config = {
  // RDF Configuration
  rdf: {
    defaultNamespaces: {
      rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
      rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
      owl: 'http://www.w3.org/2002/07/owl#',
      xsd: 'http://www.w3.org/2001/XMLSchema#',
      foaf: 'http://xmlns.com/foaf/0.1/',
      uve: 'http://uve.example.org/ns#'
    },
    // RDF types for the UVE model
    types: {
      class: 'http://www.w3.org/2000/01/rdf-schema#Class',
      property: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#Property',
      interface: 'http://uve.example.org/ns#Interface',
      subClassOf: 'http://www.w3.org/2000/01/rdf-schema#subClassOf'
    }
  },

  // Storage Configuration
  storage: {
    // Storage type: 'fs' or 'sparql'
    type: 'fs',

    // Filesystem storage settings
    basePath: '',

    // SPARQL storage settings
    endpoint: 'http://localhost:3030/uve/sparql',
    graphUri: 'http://uve.example.org/graph/main',
    prefix: 'http://uve.example.org/resource/',
    headers: {
      // Additional headers for SPARQL requests if needed
    }
  },

  // Visualization Configuration
  visualization: {
    // Class sphere settings
    sphere: {
      defaultRadius: 5,
      minRadius: 2,
      maxRadius: 10,
      defaultColor: 0x6495ED, // Cornflower blue
      selectedColor: 0xFFD700, // Gold
      opacity: 0.7,
      segments: 32
    },

    // Relationship pipe settings
    pipe: {
      defaultRadius: 0.3,
      defaultColor: 0x4682B4, // Steel blue
      selectedColor: 0xFFA500, // Orange
      segments: 8
    },

    // Interface port settings
    port: {
      defaultRadius: 0.5,
      defaultColor: 0x32CD32, // Lime green
      selectedColor: 0xFF4500, // Orange red
      segments: 16
    },

    // Camera settings
    camera: {
      fov: 75,
      near: 0.1,
      far: 1000,
      position: { x: 0, y: 0, z: 15 }
    },

    // Controls
    controls: {
      movementSpeed: 0.5,
      lookSpeed: 0.1
    }
  },

  // System settings
  system: {
    logLevel: 'info', // Possible values: trace, debug, info, warn, error
    defaultFile: 'model.ttl'
  }
};

export default config;

================
File: src/core/eventBus.js
================
/**
 * Central event bus for pub-sub messaging in UVE
 * Enables loose coupling between components
 * @module core/eventBus
 */

import log from 'loglevel';

class EventBus {
  /**
   * Create a new EventBus
   */
  constructor() {
    this.events = {};
    this.log = log.getLogger('EventBus');
  }

  /**
   * Subscribe to an event
   * @param {string} event - Event name to subscribe to
   * @param {Function} callback - Function to call when event is published
   * @returns {Function} Unsubscribe function
   */
  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    
    this.events[event].push(callback);
    this.log.debug(`Subscribed to ${event}, total subscribers: ${this.events[event].length}`);
    
    // Return unsubscribe function
    return () => {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
      this.log.debug(`Unsubscribed from ${event}, remaining subscribers: ${this.events[event].length}`);
    };
  }

  /**
   * Publish an event
   * @param {string} event - Event name to publish
   * @param {any} data - Data to pass to subscribers
   */
  publish(event, data) {
    if (!this.events[event]) {
      this.log.debug(`No subscribers for ${event}`);
      return;
    }
    
    this.log.debug(`Publishing ${event} to ${this.events[event].length} subscribers`);
    this.events[event].forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        this.log.error(`Error in subscriber callback for ${event}:`, error);
      }
    });
  }

  /**
   * Remove all subscribers for an event
   * @param {string} event - Event name to clear
   */
  clear(event) {
    if (event) {
      delete this.events[event];
      this.log.debug(`Cleared all subscribers for ${event}`);
    } else {
      this.events = {};
      this.log.debug('Cleared all subscribers for all events');
    }
  }
}

// Export a singleton instance
const eventBus = new EventBus();
export default eventBus;

================
File: src/examples/foafExample.js
================
/**
 * FOAF (Friend of a Friend) example data
 * Creates a set of 5 friends with relationships
 * @module examples/foafExample
 */

import rdf from 'rdf-ext';
import storageManager from '../util/storageManager.js';

// Add debugging
console.log('foafExample.js loading');

/**
 * Create a FOAF example dataset with 5 friends
 * @returns {Dataset} RDF dataset with FOAF data
 */
export function createFOAFExample() {
  console.log('Creating FOAF example dataset');
  const dataset = rdf.dataset();

  // Define namespaces
  const ns = {
    rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
    rdfs: rdf.namespace('http://www.w3.org/2000/01/rdf-schema#'),
    foaf: rdf.namespace('http://xmlns.com/foaf/0.1/'),
    xsd: rdf.namespace('http://www.w3.org/2001/XMLSchema#'),
    ex: rdf.namespace('http://example.org/'),
    uve: rdf.namespace('http://uve.example.org/ns#')
  };

  // Define RDF class for Person
  // First, define Person as an RDF class
  dataset.add(rdf.quad(ns.foaf.Person, ns.rdf.type, ns.rdfs.Class));
  dataset.add(rdf.quad(ns.foaf.Person, ns.rdfs.label, rdf.literal('Person')));

  dataset.add(rdf.quad(ns.foaf.Group, ns.rdf.type, ns.rdfs.Class));
  dataset.add(rdf.quad(ns.foaf.Group, ns.rdfs.label, rdf.literal('Group')));

  // Define properties for Person
  dataset.add(rdf.quad(ns.foaf.name, ns.rdf.type, ns.rdf.Property));
  dataset.add(rdf.quad(ns.foaf.name, ns.rdfs.label, rdf.literal('name')));
  dataset.add(rdf.quad(ns.foaf.name, ns.rdfs.domain, ns.foaf.Person));
  dataset.add(rdf.quad(ns.foaf.name, ns.rdfs.range, ns.xsd.string));

  dataset.add(rdf.quad(ns.foaf.mbox, ns.rdf.type, ns.rdf.Property));
  dataset.add(rdf.quad(ns.foaf.mbox, ns.rdfs.label, rdf.literal('email')));
  dataset.add(rdf.quad(ns.foaf.mbox, ns.rdfs.domain, ns.foaf.Person));
  dataset.add(rdf.quad(ns.foaf.mbox, ns.rdfs.range, ns.xsd.string));

  // Define knows relationship explicitly as a Property with domain and range
  dataset.add(rdf.quad(ns.foaf.knows, ns.rdf.type, ns.rdf.Property));
  dataset.add(rdf.quad(ns.foaf.knows, ns.rdfs.label, rdf.literal('knows')));
  dataset.add(rdf.quad(ns.foaf.knows, ns.rdfs.domain, ns.foaf.Person));
  dataset.add(rdf.quad(ns.foaf.knows, ns.rdfs.range, ns.foaf.Person));

  // Create 5 friend instances
  const people = [
    { id: 'alice', name: 'Alice Smith', email: 'alice@example.org' },
    { id: 'bob', name: 'Bob Johnson', email: 'bob@example.org' },
    { id: 'charlie', name: 'Charlie Brown', email: 'charlie@example.org' },
    { id: 'diana', name: 'Diana Parker', email: 'diana@example.org' },
    { id: 'eve', name: 'Eve Davis', email: 'eve@example.org' }
  ];

  // Add each person
  people.forEach(person => {
    const personUri = ns.ex(person.id);

    // Define the person as an instance of foaf:Person
    dataset.add(rdf.quad(personUri, ns.rdf.type, ns.foaf.Person));
    dataset.add(rdf.quad(personUri, ns.foaf.name, rdf.literal(person.name)));
    dataset.add(rdf.quad(personUri, ns.foaf.mbox, rdf.literal(person.email)));
  });

  // Define friendships (bi-directional for some, one-way for others)
  // Alice knows Bob and Charlie
  dataset.add(rdf.quad(ns.ex('alice'), ns.foaf.knows, ns.ex('bob')));
  dataset.add(rdf.quad(ns.ex('alice'), ns.foaf.knows, ns.ex('charlie')));

  // Bob knows Alice and Diana
  dataset.add(rdf.quad(ns.ex('bob'), ns.foaf.knows, ns.ex('alice')));
  dataset.add(rdf.quad(ns.ex('bob'), ns.foaf.knows, ns.ex('diana')));

  // Charlie knows Alice and Eve
  dataset.add(rdf.quad(ns.ex('charlie'), ns.foaf.knows, ns.ex('alice')));
  dataset.add(rdf.quad(ns.ex('charlie'), ns.foaf.knows, ns.ex('eve')));

  // Diana knows Bob and Eve
  dataset.add(rdf.quad(ns.ex('diana'), ns.foaf.knows, ns.ex('bob')));
  dataset.add(rdf.quad(ns.ex('diana'), ns.foaf.knows, ns.ex('eve')));

  // Eve knows Charlie and Diana
  dataset.add(rdf.quad(ns.ex('eve'), ns.foaf.knows, ns.ex('charlie')));
  dataset.add(rdf.quad(ns.ex('eve'), ns.foaf.knows, ns.ex('diana')));

  // Add some custom interfaces
  // Add Identifiable interface to Person
  dataset.add(rdf.quad(ns.ex.Identifiable, ns.rdf.type, ns.uve.Interface));
  dataset.add(rdf.quad(ns.ex.Identifiable, ns.rdfs.label, rdf.literal('Identifiable')));
  dataset.add(rdf.quad(ns.foaf.Person, ns.uve.hasInterface, ns.ex.Identifiable));

  // Add getId method to Identifiable interface
  const getIdMethod = rdf.blankNode();
  dataset.add(rdf.quad(ns.ex.Identifiable, ns.uve.hasMethod, getIdMethod));
  dataset.add(rdf.quad(getIdMethod, ns.rdfs.label, rdf.literal('getId')));
  dataset.add(rdf.quad(getIdMethod, ns.uve.hasReturnType, rdf.literal('string')));

  // Add Social interface to Person
  dataset.add(rdf.quad(ns.ex.Social, ns.rdf.type, ns.uve.Interface));
  dataset.add(rdf.quad(ns.ex.Social, ns.rdfs.label, rdf.literal('Social')));
  dataset.add(rdf.quad(ns.foaf.Person, ns.uve.hasInterface, ns.ex.Social));

  // Add addFriend method to Social interface
  const addFriendMethod = rdf.blankNode();
  dataset.add(rdf.quad(ns.ex.Social, ns.uve.hasMethod, addFriendMethod));
  dataset.add(rdf.quad(addFriendMethod, ns.rdfs.label, rdf.literal('addFriend')));
  dataset.add(rdf.quad(addFriendMethod, ns.uve.hasReturnType, rdf.literal('void')));

  // Add parameter to addFriend method
  const friendParam = rdf.blankNode();
  dataset.add(rdf.quad(addFriendMethod, ns.uve.hasParameter, friendParam));
  dataset.add(rdf.quad(friendParam, ns.rdfs.label, rdf.literal('friend')));
  dataset.add(rdf.quad(friendParam, ns.uve.hasType, rdf.literal('Person')));

  // Create a Group
  dataset.add(rdf.quad(ns.ex('friends-group'), ns.rdf.type, ns.foaf.Group));
  dataset.add(rdf.quad(ns.ex('friends-group'), ns.foaf.name, rdf.literal('Friends Group')));

  // Add all friends to the Group
  people.forEach(person => {
    dataset.add(rdf.quad(ns.ex('friends-group'), ns.foaf.member, ns.ex(person.id)));
  });

  // Save this dataset to storage for later retrieval
  saveFOAFExample(dataset);

  console.log(`FOAF example dataset created with ${dataset.size} triples`);
  return dataset;
}

/**
 * Save FOAF example dataset to storage
 * @param {Dataset} dataset - The dataset to save
 */
async function saveFOAFExample(dataset) {
  try {
    console.log('Serializing FOAF example to Turtle');

    // Use serializer from RDF-Ext
    const serializer = new rdf.serializers.TurtleSerializer();
    const turtleData = await serializer.serialize(dataset);

    // Save to storage
    await storageManager.writeFile('examples/foaf.ttl', turtleData);
    console.log('FOAF example saved to storage');
  } catch (error) {
    console.error('Error saving FOAF example:', error);
  }
}

/**
 * Load FOAF example dataset from storage
 * @returns {Promise<Dataset>} The loaded dataset
 */
export async function loadFOAFExample() {
  console.log('Attempting to load FOAF example from storage');
  try {
    // Check if example exists in storage
    const exists = await storageManager.exists('examples/foaf.ttl');
    console.log('FOAF example exists in storage:', exists);

    if (exists) {
      // Load from storage
      const turtleData = await storageManager.readFile('examples/foaf.ttl', { encoding: 'utf8' });
      console.log('FOAF data loaded from storage, parsing...');

      // Parse the Turtle data
      const parser = new rdf.parsers.TurtleParser();
      const dataset = await parser.parse(turtleData);
      console.log(`FOAF dataset parsed with ${dataset.size} triples`);
      return dataset;
    } else {
      // Create new example if not found
      console.log('FOAF example not found in storage, creating new one');
      return createFOAFExample();
    }
  } catch (error) {
    console.error('Error loading FOAF example:', error);
    // Fall back to creating a new example
    console.log('Falling back to creating a new FOAF example');
    return createFOAFExample();
  }
}

// Also provide a default export for backward compatibility
export default createFOAFExample;

================
File: src/model/entityTypes/classEntity.js
================
/**
 * ClassEntity represents a class in the UVE model
 * Maps to a sphere in the visualization
 * @module model/entityTypes/classEntity
 */

/**
 * Entity representing a class
 */
class ClassEntity {
  /**
   * Create a new ClassEntity
   * @param {Object} params - Parameters
   * @param {Term} params.uri - RDF URI of the class
   * @param {string} params.label - Human-readable label for the class
   * @param {Array<string>} [params.interfaces=[]] - Interface URIs attached to this class
   * @param {Array<string>} [params.subclasses=[]] - Subclass URIs contained in this class
   * @param {Object} [params.position] - 3D position of the class sphere
   * @param {number} [params.position.x=0] - X coordinate
   * @param {number} [params.position.y=0] - Y coordinate
   * @param {number} [params.position.z=0] - Z coordinate
   * @param {number} [params.radius] - Radius of the class sphere, calculated from subclasses if not provided
   */
  constructor({ uri, label, interfaces = [], subclasses = [], position = { x: 0, y: 0, z: 0 }, radius }) {
    this.uri = uri;
    this.label = label;
    this.interfaces = interfaces;
    this.subclasses = subclasses;
    this.position = position;
    this._radius = radius;
    
    // Additional metadata
    this.properties = [];
    this.isSelected = false;
  }
  
  /**
   * Get the calculated or explicit radius
   * @returns {number} Radius value
   */
  get radius() {
    if (this._radius) {
      return this._radius;
    }
    
    // Calculate radius based on subclass count if not explicitly set
    const baseRadius = 5;
    const subclassMultiplier = 0.5;
    return baseRadius + (this.subclasses.length * subclassMultiplier);
  }
  
  /**
   * Set the radius explicitly
   * @param {number} value - New radius value
   */
  set radius(value) {
    this._radius = value;
  }
  
  /**
   * Add an interface to this class
   * @param {string} interfaceUri - URI of the interface to add
   */
  addInterface(interfaceUri) {
    if (!this.interfaces.includes(interfaceUri)) {
      this.interfaces.push(interfaceUri);
    }
  }
  
  /**
   * Add a subclass to this class
   * @param {string} subclassUri - URI of the subclass to add
   */
  addSubclass(subclassUri) {
    if (!this.subclasses.includes(subclassUri)) {
      this.subclasses.push(subclassUri);
    }
  }
  
  /**
   * Add a property to this class
   * @param {Object} property - Property object
   * @param {Term} property.predicate - Predicate term
   * @param {Term} property.object - Object term
   */
  addProperty(property) {
    this.properties.push(property);
  }
  
  /**
   * Serialize to JSON
   * @returns {Object} JSON representation
   */
  toJSON() {
    return {
      uri: this.uri.value,
      label: this.label,
      interfaces: this.interfaces.map(i => i.value),
      subclasses: this.subclasses.map(s => s.value),
      position: this.position,
      radius: this.radius,
      properties: this.properties.map(p => ({
        predicate: p.predicate.value,
        object: p.object.value
      }))
    };
  }
}

export default ClassEntity;

================
File: src/model/entityTypes/interfaceEntity.js
================
/**
 * InterfaceEntity represents an interface on a class
 * Maps to a port on a sphere in the visualization
 * @module model/entityTypes/interfaceEntity
 */

/**
 * Entity representing an interface
 */
class InterfaceEntity {
  /**
   * Create a new InterfaceEntity
   * @param {Object} params - Parameters
   * @param {Term} params.uri - RDF URI of the interface
   * @param {string} params.label - Human-readable label for the interface
   * @param {Term} params.classUri - URI of the class this interface belongs to
   * @param {Object} [params.position] - Spherical position on the class sphere
   * @param {number} [params.position.phi=0] - Horizontal angle (0-2π)
   * @param {number} [params.position.theta=0] - Vertical angle (0-π)
   * @param {Object} [params.metadata={}] - Additional metadata for the interface
   */
  constructor({ uri, label, classUri, position = { phi: 0, theta: 0 }, metadata = {} }) {
    this.uri = uri;
    this.label = label;
    this.classUri = classUri;
    this.position = position;
    this.metadata = metadata;
    
    // Methods provided by this interface
    this.methods = [];
    
    // Track visualization state
    this.isSelected = false;
    this.isVisible = true;
  }
  
  /**
   * Add a method to this interface
   * @param {Object} method - Method information
   * @param {string} method.name - Method name
   * @param {Array<Object>} [method.parameters=[]] - Method parameters
   * @param {string} [method.returnType] - Return type of the method
   */
  addMethod(method) {
    this.methods.push(method);
  }
  
  /**
   * Calculate a 3D position on the sphere based on spherical coordinates
   * @param {number} radius - Radius of the class sphere
   * @returns {Object} 3D coordinates {x, y, z}
   */
  getPositionOnSphere(radius) {
    const { phi, theta } = this.position;
    
    return {
      x: radius * Math.sin(theta) * Math.cos(phi),
      y: radius * Math.sin(theta) * Math.sin(phi),
      z: radius * Math.cos(theta)
    };
  }
  
  /**
   * Update the position of this interface on the sphere
   * @param {number} phi - Horizontal angle (0-2π)
   * @param {number} theta - Vertical angle (0-π)
   */
  updatePosition(phi, theta) {
    this.position.phi = phi;
    this.position.theta = theta;
  }
  
  /**
   * Toggle selection state
   * @returns {boolean} New selection state
   */
  toggleSelection() {
    this.isSelected = !this.isSelected;
    return this.isSelected;
  }
  
  /**
   * Serialize to JSON
   * @returns {Object} JSON representation
   */
  toJSON() {
    return {
      uri: this.uri.value,
      label: this.label,
      classUri: this.classUri.value,
      position: this.position,
      methods: this.methods,
      metadata: this.metadata
    };
  }
}

export default InterfaceEntity;

================
File: src/model/entityTypes/relationshipEntity.js
================
/**
 * RelationshipEntity represents a relationship between classes
 * Maps to a pipe in the visualization
 * @module model/entityTypes/relationshipEntity
 */

/**
 * Entity representing a relationship between classes
 */
class RelationshipEntity {
  /**
   * Create a new RelationshipEntity
   * @param {Object} params - Parameters
   * @param {Term} params.uri - RDF URI of the relationship property
   * @param {string} params.label - Human-readable label for the relationship
   * @param {Term} params.sourceClassUri - URI of the source class
   * @param {Term} params.targetClassUri - URI of the target class
   * @param {string} [params.type='default'] - Type of relationship
   * @param {Object} [params.metadata={}] - Additional metadata for the relationship
   */
  constructor({ uri, label, sourceClassUri, targetClassUri, type = 'default', metadata = {} }) {
    this.uri = uri;
    this.label = label;
    this.sourceClassUri = sourceClassUri;
    this.targetClassUri = targetClassUri;
    this.type = type;
    this.metadata = metadata;
    
    // Track visualization state
    this.isSelected = false;
    this.isVisible = true;
  }
  
  /**
   * Check if this relationship connects the given classes
   * @param {Term} class1Uri - First class URI
   * @param {Term} class2Uri - Second class URI
   * @returns {boolean} True if this relationship connects the classes in any direction
   */
  connectsClasses(class1Uri, class2Uri) {
    return (
      (this.sourceClassUri.equals(class1Uri) && this.targetClassUri.equals(class2Uri)) ||
      (this.sourceClassUri.equals(class2Uri) && this.targetClassUri.equals(class1Uri))
    );
  }
  
  /**
   * Get the direction of the relationship between two classes
   * @param {Term} fromClassUri - Source class URI
   * @param {Term} toClassUri - Target class URI
   * @returns {number} 1 if direction matches, -1 if reversed, 0 if not connected
   */
  getDirection(fromClassUri, toClassUri) {
    if (this.sourceClassUri.equals(fromClassUri) && this.targetClassUri.equals(toClassUri)) {
      return 1;
    } else if (this.sourceClassUri.equals(toClassUri) && this.targetClassUri.equals(fromClassUri)) {
      return -1;
    } else {
      return 0;
    }
  }
  
  /**
   * Toggle selection state
   * @returns {boolean} New selection state
   */
  toggleSelection() {
    this.isSelected = !this.isSelected;
    return this.isSelected;
  }
  
  /**
   * Serialize to JSON
   * @returns {Object} JSON representation
   */
  toJSON() {
    return {
      uri: this.uri.value,
      label: this.label,
      sourceClassUri: this.sourceClassUri.value,
      targetClassUri: this.targetClassUri.value,
      type: this.type,
      metadata: this.metadata
    };
  }
}

export default RelationshipEntity;

================
File: src/model/conceptModel.js
================
/**
 * Conceptual model that transforms RDF data into domain entities
 * @module model/conceptModel
 */

import log from 'loglevel';
import eventBus from '../core/eventBus.js';
import config from '../core/config.js';
import ClassEntity from './entityTypes/classEntity.js';
import RelationshipEntity from './entityTypes/relationshipEntity.js';
import InterfaceEntity from './entityTypes/interfaceEntity.js';

class ConceptModel {
  /**
   * Create a new ConceptModel
   * @param {RDFModel} rdfModel - RDF data model
   */
  constructor(rdfModel) {
    this.rdfModel = rdfModel;
    this.classes = new Map(); // URI string -> ClassEntity
    this.relationships = new Map(); // URI string -> RelationshipEntity
    this.interfaces = new Map(); // URI string -> InterfaceEntity
    this.log = log.getLogger('ConceptModel');

    // Subscribe to RDF model changes
    eventBus.subscribe('rdf-model-changed', () => this.updateFromRDF());

    console.log('ConceptModel created');
  }

  /**
   * Update the conceptual model from RDF data
   */
  updateFromRDF() {
    this.log.info('Updating conceptual model from RDF data');
    console.log('Updating conceptual model from RDF data');

    // Clear current entities
    this.classes.clear();
    this.relationships.clear();
    this.interfaces.clear();

    console.log('Loading classes...');
    // Load classes
    this._loadClasses();

    console.log('Loading relationships...');
    // Load relationships between classes
    this._loadRelationships();

    console.log('Loading interfaces...');
    // Load interfaces
    this._loadInterfaces();

    console.log('Assigning positions...');
    // Assign positions to classes (simple circle layout for now)
    this._assignPositions();

    // Notify that the concept model has changed
    console.log('Publishing concept-model-changed event');
    eventBus.publish('concept-model-changed', {
      classes: Array.from(this.classes.values()),
      relationships: Array.from(this.relationships.values()),
      interfaces: Array.from(this.interfaces.values())
    });

    console.log('ConceptModel updated with:', {
      classes: this.classes.size,
      relationships: this.relationships.size,
      interfaces: this.interfaces.size
    });
  }

  /**
   * Load classes from RDF model
   * @private
   */
  _loadClasses() {
    console.log('Loading classes and class instances from RDF model');

    // First load the class definitions
    this._loadClassDefinitions();

    // Then load instances of those classes
    this._loadClassInstances();

    // Now that all classes are loaded, find subclass relationships
    console.log('Loading subclass relationships');
    this._loadSubclassRelationships();

    console.log(`Loaded ${this.classes.size} classes`);
  }

  /**
   * Load RDF class definitions
   * @private
   */
  _loadClassDefinitions() {
    try {
      const classNodes = this.rdfModel.getClasses();
      console.log('Loading class definitions, classNodes type:', typeof classNodes);

      // Debug output of classNodes
      console.log('classNodes methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(classNodes)));
      console.log('Is Grapoi object:', classNodes.constructor.name);

      // Handle Grapoi objects properly
      // We need to use forEach method of Grapoi or convert to array if it has values property
      if (classNodes && typeof classNodes.forEach === 'function') {
        console.log('Using Grapoi forEach method');

        // Use Grapoi's own forEach method
        classNodes.forEach(classNode => {
          this._processClassNode(classNode);
        });
      } else if (classNodes && Array.isArray(classNodes.values)) {
        console.log('Using values array from Grapoi object');

        // Use the values array
        classNodes.values.forEach(classNode => {
          this._processClassNode(classNode);
        });
      } else {
        console.error('classNodes is not iterable:', classNodes);
        // Attempt to handle as single node if possible
        if (classNodes && classNodes.term) {
          this._processClassNode(classNodes);
        }
      }
    } catch (error) {
      console.error('Error loading class definitions:', error);
    }
  }

  /**
   * Process a single class node from RDF
   * @param {Object} classNode - Grapoi node for a class
   * @private
   */
  _processClassNode(classNode) {
    try {
      const uri = classNode.term;
      const uriString = uri.value;

      console.log('Processing class node:', uriString);

      // Skip if we already have this class
      if (this.classes.has(uriString)) {
        return;
      }

      // Get label for the class
      let label = this._extractLabelFromUri(uriString);
      try {
        const labels = classNode.out(this.rdfModel.namespaces.rdfs.label);
        if (labels && labels.values && labels.values.length > 0) {
          label = labels.values[0];
        }
      } catch (error) {
        console.warn(`Error getting label for class ${uriString}:`, error);
      }

      // Create class entity
      const classEntity = new ClassEntity({
        uri,
        label,
        subclasses: []
      });

      // Add properties
      try {
        const properties = this.rdfModel.getProperties(uri);
        properties.forEach(property => {
          classEntity.addProperty(property);
        });
      } catch (error) {
        console.warn(`Error getting properties for class ${uriString}:`, error);
      }

      this.classes.set(uriString, classEntity);
      this.log.debug(`Loaded class: ${label} (${uriString})`);
      console.log(`Loaded class: ${label} (${uriString})`);
    } catch (error) {
      console.error('Error processing class node:', error);
    }
  }

  /**
   * Load instances of RDF classes
   * @private
   */
  _loadClassInstances() {
    try {
      // For each class we've found
      for (const classEntity of this.classes.values()) {
        console.log(`Looking for instances of class: ${classEntity.label}`);

        // Get all instances of this class
        try {
          const instanceNodes = this.rdfModel.getClassInstances(classEntity.uri);

          if (instanceNodes && typeof instanceNodes.forEach === 'function') {
            console.log('Using Grapoi forEach for instances');
            instanceNodes.forEach(instanceNode => {
              this._processInstanceNode(instanceNode, classEntity);
            });
          } else if (instanceNodes && Array.isArray(instanceNodes.values)) {
            console.log('Using values array for instances');
            instanceNodes.values.forEach(instanceNode => {
              this._processInstanceNode(instanceNode, classEntity);
            });
          } else {
            console.log('No instances found or not iterable:', instanceNodes);
          }
        } catch (error) {
          console.warn(`Error getting instances for class ${classEntity.label}:`, error);
        }
      }
    } catch (error) {
      console.error('Error loading class instances:', error);
    }
  }

  /**
   * Process a class instance node
   * @param {Object} instanceNode - Instance node
   * @param {ClassEntity} parentClassEntity - Parent class entity
   * @private
   */
  _processInstanceNode(instanceNode, parentClassEntity) {
    try {
      const uri = instanceNode.term;
      const uriString = uri.value;

      console.log('Processing instance:', uriString, 'of class', parentClassEntity.label);

      // Skip if we already have this instance
      if (this.classes.has(uriString)) {
        console.log('Instance already processed, skipping:', uriString);
        return;
      }

      // Get label for the instance
      let label = this._extractLabelFromUri(uriString);
      try {
        // Try to get foaf:name first for FOAF instances
        const names = instanceNode.out(this.rdfModel.namespaces.foaf.name);
        if (names && names.values && names.values.length > 0) {
          label = names.values[0];
        } else {
          // Fall back to rdfs:label
          const labels = instanceNode.out(this.rdfModel.namespaces.rdfs.label);
          if (labels && labels.values && labels.values.length > 0) {
            label = labels.values[0];
          }
        }
      } catch (error) {
        console.warn(`Error getting label for instance ${uriString}:`, error);
      }

      // Create class entity for this instance
      const classEntity = new ClassEntity({
        uri,
        label,
        subclasses: []
      });

      // Add properties
      try {
        const properties = this.rdfModel.getProperties(uri);
        properties.forEach(property => {
          classEntity.addProperty(property);
        });
      } catch (error) {
        console.warn(`Error getting properties for instance ${uriString}:`, error);
      }

      this.classes.set(uriString, classEntity);
      this.log.debug(`Loaded instance: ${label} (${uriString}) of class ${parentClassEntity.label}`);
      console.log(`Loaded instance: ${label} (${uriString}) of class ${parentClassEntity.label}`);
    } catch (error) {
      console.error('Error processing instance node:', error);
    }
  }

  /**
   * Load subclass relationships
   * @private
   */
  _loadSubclassRelationships() {
    for (const classEntity of this.classes.values()) {
      try {
        const subclasses = this.rdfModel.getSubclasses(classEntity.uri);

        if (subclasses && typeof subclasses.forEach === 'function') {
          // Use Grapoi's forEach
          subclasses.forEach(subclass => {
            this._processSubclass(classEntity, subclass);
          });
        } else if (subclasses && Array.isArray(subclasses.values)) {
          // Use values array
          subclasses.values.forEach(subclass => {
            this._processSubclass(classEntity, subclass);
          });
        } else {
          console.warn(`Subclasses for ${classEntity.label} is not iterable:`, subclasses);
          // Try as single node
          if (subclasses && subclasses.term) {
            this._processSubclass(classEntity, subclasses);
          }
        }
      } catch (error) {
        console.error(`Error loading subclasses for ${classEntity.label}:`, error);
      }
    }
  }

  /**
   * Process a single subclass
   * @param {ClassEntity} classEntity - Parent class
   * @param {Object} subclass - Subclass node
   * @private
   */
  _processSubclass(classEntity, subclass) {
    const subclassUri = subclass.term;
    const subclassUriString = subclassUri.value;

    // Only process if the subclass is a known class
    if (this.classes.has(subclassUriString)) {
      classEntity.addSubclass(subclassUri);
      console.log(`Added subclass ${subclassUriString} to ${classEntity.label}`);
    }
  }

  /**
   * Load relationships between classes
   * @private
   */
  _loadRelationships() {
    const relationships = this.rdfModel.getRelationships();
    console.log('Loading relationships:', relationships);

    if (!relationships || !Array.isArray(relationships)) {
      console.warn('No relationships found or invalid format:', relationships);
      return;
    }

    relationships.forEach(rel => {
      try {
        const { property, domain, range } = rel;
        const propertyUriString = property.value;

        // Skip if we already have this relationship
        if (this.relationships.has(propertyUriString)) {
          return;
        }

        // Get label for the relationship
        let label = this._extractLabelFromUri(propertyUriString);
        try {
          const propertyNode = this.rdfModel.grapoi.node(property);
          const labels = propertyNode.out(this.rdfModel.namespaces.rdfs.label);
          if (labels && labels.values && labels.values.length > 0) {
            label = labels.values[0];
          }
        } catch (error) {
          console.warn(`Error getting label for relationship ${propertyUriString}:`, error);
        }

        // Create relationship entity
        const relationshipEntity = new RelationshipEntity({
          uri: property,
          label,
          sourceClassUri: domain,
          targetClassUri: range
        });

        this.relationships.set(propertyUriString, relationshipEntity);
        this.log.debug(`Loaded relationship: ${label} (${propertyUriString})`);
        console.log(`Loaded relationship: ${label} (${propertyUriString})`);
      } catch (error) {
        console.error('Error processing relationship:', error);
      }
    });
  }

  /**
   * Load interfaces
   * @private
   */
  _loadInterfaces() {
    try {
      const interfaceType = this.rdfModel.namedNode(config.rdf.types.interface);
      const interfaces = this.rdfModel.grapoi.node(interfaceType).in(this.rdfModel.namespaces.rdf.type);
      console.log('Loading interfaces, type:', typeof interfaces);

      if (interfaces && typeof interfaces.forEach === 'function') {
        // Use Grapoi's forEach
        interfaces.forEach(interfaceNode => {
          this._processInterface(interfaceNode);
        });
      } else if (interfaces && Array.isArray(interfaces.values)) {
        // Use values array
        interfaces.values.forEach(interfaceNode => {
          this._processInterface(interfaceNode);
        });
      } else {
        console.warn('Interfaces is not iterable:', interfaces);
        // Try as single node
        if (interfaces && interfaces.term) {
          this._processInterface(interfaces);
        }
      }
    } catch (error) {
      console.error('Error loading interfaces:', error);
    }
  }

  /**
   * Process a single interface node
   * @param {Object} interfaceNode - Interface node
   * @private
   */
  _processInterface(interfaceNode) {
    try {
      const uri = interfaceNode.term;
      const uriString = uri.value;

      // Skip if we already have this interface
      if (this.interfaces.has(uriString)) {
        return;
      }

      // Get label for the interface
      let label = this._extractLabelFromUri(uriString);
      try {
        const labels = interfaceNode.out(this.rdfModel.namespaces.rdfs.label);
        if (labels && labels.values && labels.values.length > 0) {
          label = labels.values[0];
        }
      } catch (error) {
        console.warn(`Error getting label for interface ${uriString}:`, error);
      }

      // Find the class this interface belongs to
      let classUri = null;
      try {
        const classNodes = interfaceNode.in(this.rdfModel.namespaces.uve.hasInterface);
        if (classNodes && classNodes.values && classNodes.values.length > 0) {
          classUri = classNodes.term;
        }
      } catch (error) {
        console.warn(`Error finding class for interface ${uriString}:`, error);
      }

      if (!classUri) {
        this.log.warn(`Interface ${label} (${uriString}) not attached to any class`);
        console.warn(`Interface ${label} (${uriString}) not attached to any class`);
        return;
      }

      const classUriString = classUri.value;

      if (!this.classes.has(classUriString)) {
        this.log.warn(`Interface ${label} attached to unknown class ${classUriString}`);
        console.warn(`Interface ${label} attached to unknown class ${classUriString}`);
        return;
      }

      // Create random spherical position
      const position = {
        phi: Math.random() * Math.PI * 2, // 0 to 2π
        theta: Math.random() * Math.PI // 0 to π
      };

      // Create interface entity
      const interfaceEntity = new InterfaceEntity({
        uri,
        label,
        classUri,
        position
      });

      // Add methods to the interface (if any)
      try {
        const methods = interfaceNode.out(this.rdfModel.namespaces.uve.hasMethod);

        if (methods && typeof methods.forEach === 'function') {
          methods.forEach(methodNode => {
            this._processInterfaceMethod(methodNode, interfaceEntity);
          });
        } else if (methods && Array.isArray(methods.values)) {
          methods.values.forEach(methodNode => {
            this._processInterfaceMethod(methodNode, interfaceEntity);
          });
        }
      } catch (error) {
        console.warn(`Error processing methods for interface ${uriString}:`, error);
      }

      this.interfaces.set(uriString, interfaceEntity);

      // Add interface to class
      const classEntity = this.classes.get(classUriString);
      classEntity.addInterface(uri);

      this.log.debug(`Loaded interface: ${label} (${uriString}) for class ${classEntity.label}`);
      console.log(`Loaded interface: ${label} (${uriString}) for class ${classEntity.label}`);
    } catch (error) {
      console.error('Error processing interface:', error);
    }
  }

  /**
   * Process a method on an interface
   * @param {Object} methodNode - Method node
   * @param {InterfaceEntity} interfaceEntity - Interface entity
   * @private
   */
  _processInterfaceMethod(methodNode, interfaceEntity) {
    try {
      // Get method name
      let methodName = methodNode.term.value.split('#').pop().split('/').pop();
      try {
        const labels = methodNode.out(this.rdfModel.namespaces.rdfs.label);
        if (labels && labels.values && labels.values.length > 0) {
          methodName = labels.values[0];
        }
      } catch (error) {
        console.warn(`Error getting name for method:`, error);
      }

      const methodParams = [];

      // Get parameters
      try {
        const paramNodes = methodNode.out(this.rdfModel.namespaces.uve.hasParameter);

        if (paramNodes && typeof paramNodes.forEach === 'function') {
          paramNodes.forEach(paramNode => {
            this._processMethodParameter(paramNode, methodParams);
          });
        } else if (paramNodes && Array.isArray(paramNodes.values)) {
          paramNodes.values.forEach(paramNode => {
            this._processMethodParameter(paramNode, methodParams);
          });
        }
      } catch (error) {
        console.warn(`Error processing parameters for method ${methodName}:`, error);
      }

      // Get return type
      let returnType = 'void';
      try {
        const returnTypes = methodNode.out(this.rdfModel.namespaces.uve.hasReturnType);
        if (returnTypes && returnTypes.values && returnTypes.values.length > 0) {
          returnType = returnTypes.values[0];
        }
      } catch (error) {
        console.warn(`Error getting return type for method ${methodName}:`, error);
      }

      interfaceEntity.addMethod({
        name: methodName,
        parameters: methodParams,
        returnType
      });

      console.log(`Added method ${methodName} to interface ${interfaceEntity.label}`);
    } catch (error) {
      console.error('Error processing method:', error);
    }
  }

  /**
   * Process a parameter on a method
   * @param {Object} paramNode - Parameter node
   * @param {Array} methodParams - Array to add the parameter to
   * @private
   */
  _processMethodParameter(paramNode, methodParams) {
    try {
      // Get parameter name
      let paramName = paramNode.term.value.split('#').pop().split('/').pop();
      try {
        const labels = paramNode.out(this.rdfModel.namespaces.rdfs.label);
        if (labels && labels.values && labels.values.length > 0) {
          paramName = labels.values[0];
        }
      } catch (error) {
        console.warn(`Error getting name for parameter:`, error);
      }

      // Get parameter type
      let paramType = 'any';
      try {
        const types = paramNode.out(this.rdfModel.namespaces.uve.hasType);
        if (types && types.values && types.values.length > 0) {
          paramType = types.values[0];
        }
      } catch (error) {
        console.warn(`Error getting type for parameter ${paramName}:`, error);
      }

      methodParams.push({
        name: paramName,
        type: paramType
      });
    } catch (error) {
      console.error('Error processing parameter:', error);
    }
  }

  /**
   * Assign positions to classes
   * @private
   */
  _assignPositions() {
    const classes = Array.from(this.classes.values());
    const classCount = classes.length;

    if (classCount === 0) {
      return;
    }

    console.log(`Assigning positions to ${classCount} classes`);

    // For a single class, place it at origin
    if (classCount === 1) {
      classes[0].position = { x: 0, y: 0, z: 0 };
      return;
    }

    // For multiple classes, arrange in a circle on the XZ plane
    const radius = Math.max(30, classCount * 5);
    const angleStep = (Math.PI * 2) / classCount;

    classes.forEach((classEntity, index) => {
      const angle = index * angleStep;

      classEntity.position = {
        x: radius * Math.sin(angle),
        y: 0,
        z: radius * Math.cos(angle)
      };

      console.log(`Positioned class ${classEntity.label} at (${classEntity.position.x.toFixed(2)}, ${classEntity.position.y.toFixed(2)}, ${classEntity.position.z.toFixed(2)})`);
    });
  }

  /**
   * Extract a human-readable label from a URI
   * @param {string} uri - URI to extract label from
   * @returns {string} Extracted label
   * @private
   */
  _extractLabelFromUri(uri) {
    // Try to extract the fragment
    let label = uri.split('#').pop();

    // If no fragment, try the last path segment
    if (label === uri) {
      label = uri.split('/').pop();
    }

    return label;
  }

  /**
   * Get a class entity by URI
   * @param {Term|string} uri - Class URI
   * @returns {ClassEntity|null} Class entity or null if not found
   */
  getClass(uri) {
    const uriString = typeof uri === 'string' ? uri : uri.value;
    return this.classes.get(uriString) || null;
  }

  /**
   * Get relationships for a class
   * @param {Term|string} classUri - Class URI
   * @returns {Array<RelationshipEntity>} Relationships involving the class
   */
  getClassRelationships(classUri) {
    const uriString = typeof classUri === 'string' ? classUri : uri.value;

    return Array.from(this.relationships.values()).filter(rel => {
      return rel.sourceClassUri.value === uriString || rel.targetClassUri.value === uriString;
    });
  }

  /**
   * Get interfaces for a class
   * @param {Term|string} classUri - Class URI
   * @returns {Array<InterfaceEntity>} Interfaces for the class
   */
  getClassInterfaces(classUri) {
    const uriString = typeof classUri === 'string' ? classUri : uri.value;

    return Array.from(this.interfaces.values()).filter(intf => {
      return intf.classUri.value === uriString;
    });
  }

  /**
   * Get a relationship entity by URI
   * @param {Term|string} uri - Relationship URI
   * @returns {RelationshipEntity|null} Relationship entity or null if not found
   */
  getRelationship(uri) {
    const uriString = typeof uri === 'string' ? uri : uri.value;
    return this.relationships.get(uriString) || null;
  }

  /**
   * Get an interface entity by URI
   * @param {Term|string} uri - Interface URI
   * @returns {InterfaceEntity|null} Interface entity or null if not found
   */
  getInterface(uri) {
    const uriString = typeof uri === 'string' ? uri : uri.value;
    return this.interfaces.get(uriString) || null;
  }
}

export default ConceptModel;

================
File: src/model/rdfModel.js
================
/**
 * RDF data model for UVE
 * Manages RDF datasets using RDF-Ext and Grapoi
 * @module model/rdfModel
 */

import rdf from 'rdf-ext';
import log from 'loglevel';
import eventBus from '../core/eventBus.js';
import config from '../core/config.js';
import storageManager from '../util/storageManager.js';

class RDFModel {
  /**
   * Create a new RDF Model
   */
  constructor() {
    this.dataset = rdf.dataset();
    this.grapoi = rdf.grapoi({ dataset: this.dataset });
    this.namespaces = {};
    this.log = log.getLogger('RDFModel');

    // Initialize namespaces
    Object.entries(config.rdf.defaultNamespaces).forEach(([prefix, uri]) => {
      this.namespaces[prefix] = rdf.namespace(uri);
    });
  }

  /**
   * Load RDF data from storage
   * @param {string} id - Resource identifier
   * @returns {Promise<rdf.Dataset>} The loaded dataset
   */
  async loadFromStorage(id) {
    try {
      this.log.info(`Loading RDF data from storage: ${id}`);

      // Read from storage
      const content = await storageManager.readFile(id, { encoding: 'utf8' });

      // Determine format from file extension
      const format = this.getFormatFromId(id);

      // Clear existing dataset
      this.dataset = rdf.dataset();

      // Parse content into dataset
      const parser = new this._getParser(format);
      const quads = parser.parse(content);
      for (const quad of quads) {
        this.dataset.add(quad);
      }

      // Reinitialize grapoi with new dataset
      this.grapoi = rdf.grapoi({ dataset: this.dataset });

      this.log.info(`Loaded ${this.dataset.size} triples from ${id}`);
      eventBus.publish('rdf-model-changed', { source: 'storage', id });

      return this.dataset;
    } catch (error) {
      this.log.error(`Error loading RDF data from ${id}:`, error);
      throw error;
    }
  }

  /**
   * Save RDF data to storage
   * @param {string} id - Resource identifier
   * @returns {Promise<void>}
   */
  async saveToStorage(id) {
    try {
      this.log.info(`Saving RDF data to storage: ${id}`);

      // Determine format from file extension
      const format = this.getFormatFromId(id);

      // Serialize dataset to string
      const serializer = new this._getSerializer(format);
      const content = serializer.serialize(this.dataset);

      // Write to storage
      await storageManager.writeFile(id, content);

      this.log.info(`Saved ${this.dataset.size} triples to ${id}`);
    } catch (error) {
      this.log.error(`Error saving RDF data to ${id}:`, error);
      throw error;
    }
  }

  /**
   * Load RDF data from a Turtle file (for backward compatibility)
   * @param {string} filePath - Path to the Turtle file
   * @returns {Promise<rdf.Dataset>} The loaded dataset
   * @deprecated Use loadFromStorage instead
   */
  async loadFromFile(filePath) {
    return this.loadFromStorage(filePath);
  }

  /**
   * Save RDF data to a Turtle file (for backward compatibility)
   * @param {string} filePath - Path to save the Turtle file
   * @returns {Promise<void>}
   * @deprecated Use saveToStorage instead
   */
  async saveToFile(filePath) {
    return this.saveToStorage(filePath);
  }

  /**
   * Add a triple to the dataset
   * @param {Term} subject - Subject term
   * @param {Term} predicate - Predicate term
   * @param {Term} object - Object term
   */
  addTriple(subject, predicate, object) {
    const quad = rdf.quad(subject, predicate, object);
    this.dataset.add(quad);
    this.log.debug(`Added triple: ${quad.toString()}`);
    eventBus.publish('rdf-model-changed', { source: 'addTriple', quad });
  }

  /**
   * Remove a triple from the dataset
   * @param {Term} subject - Subject term
   * @param {Term} predicate - Predicate term
   * @param {Term} object - Object term
   */
  removeTriple(subject, predicate, object) {
    const matches = this.dataset.match(subject, predicate, object);
    this.dataset.deleteMatches(subject, predicate, object);
    this.log.debug(`Removed ${matches.size} triples`);
    eventBus.publish('rdf-model-changed', { source: 'removeTriple', matches });
  }

  /**
   * Get all RDF classes from the dataset
   * @returns {Grapoi} Grapoi object containing class nodes
   */
  getClasses() {
    return this.grapoi.node(this.namespaces.rdfs.Class)
      .in(this.namespaces.rdf.type);
  }

  /**
   * Get all properties for a given subject
   * @param {Term} subject - Subject term
   * @returns {Array<Object>} Array of property objects with predicate and object
   */
  getProperties(subject) {
    const properties = [];
    const matches = this.dataset.match(subject);

    for (const quad of matches) {
      properties.push({
        predicate: quad.predicate,
        object: quad.object
      });
    }

    return properties;
  }

  /**
   * Get subclasses of a given class
   * @param {Term} classUri - URI of the class
   * @returns {Grapoi} Grapoi object containing subclass nodes
   */
  getSubclasses(classUri) {
    return this.grapoi.node(classUri)
      .in(this.namespaces.rdfs.subClassOf);
  }

  /**
   * Get interfaces for a class
   * @param {Term} classUri - URI of the class
   * @returns {Grapoi} Grapoi object containing interface nodes
   */
  getInterfaces(classUri) {
    return this.grapoi.node(classUri)
      .out(this.namespaces.uve.hasInterface);
  }

  /**
   * Get relationships between classes
   * @returns {Array<Object>} Array of relationship objects
   */
  getRelationships() {
    const relationships = [];
    const properties = this.grapoi.node(this.namespaces.rdf.Property)
      .in(this.namespaces.rdf.type);

    for (const property of properties) {
      const domains = property.out(this.namespaces.rdfs.domain);
      const ranges = property.out(this.namespaces.rdfs.range);

      // For each domain-range pair, create a relationship
      for (const domain of domains) {
        for (const range of ranges) {
          relationships.push({
            property: property.term,
            domain: domain.term,
            range: range.term
          });
        }
      }
    }

    return relationships;
  }

  /**
   * Create a named node with the given URI
   * @param {string} uri - URI for the named node
   * @returns {NamedNode} RDF named node
   */
  namedNode(uri) {
    return rdf.namedNode(uri);
  }

  /**
   * Create a literal with the given value
   * @param {string} value - Value for the literal
   * @param {string} [datatype] - Optional datatype URI
   * @returns {Literal} RDF literal
   */
  literal(value, datatype) {
    return datatype ?
      rdf.literal(value, null, rdf.namedNode(datatype)) :
      rdf.literal(value);
  }

  /**
   * Get RDF format from resource identifier
   * @param {string} id - Resource identifier
   * @returns {string} MIME type for the format
   * @private
   */
  getFormatFromId(id) {
    const extension = id.split('.').pop().toLowerCase();

    const formatMap = {
      ttl: 'text/turtle',
      nt: 'application/n-triples',
      nq: 'application/n-quads',
      trig: 'application/trig',
      jsonld: 'application/ld+json',
      json: 'application/ld+json'
    };

    return formatMap[extension] || 'text/turtle';
  }

  /**
   * Get parser for a given format
   * @param {string} format - MIME type
   * @returns {Object} Parser for the format
   * @private
   */
  _getParser(format) {
    return rdf.formats.parsers.get(format);
  }

  /**
   * Get serializer for a given format
   * @param {string} format - MIME type
   * @returns {Object} Serializer for the format
   * @private
   */
  _getSerializer(format) {
    return rdf.formats.serializers.get(format);
  }

  /**
 * Get instances of a given class
 * @param {Term} classUri - URI of the class
 * @returns {Grapoi} Grapoi object containing instance nodes
 */
  getClassInstances(classUri) {
    console.log(`Getting instances of class: ${classUri.value}`);
    try {
      // Find all nodes that have rdf:type with value of classUri
      const instances = this.grapoi.node(classUri).in(this.namespaces.rdf.type);
      console.log(`Found ${instances.values ? instances.values.length : 'unknown number of'} instances`);
      return instances;
    } catch (error) {
      console.error(`Error getting instances of class ${classUri.value}:`, error);
      return { values: [] }; // Return empty result on error
    }
  }
}

export default RDFModel;

================
File: src/styles/main.css
================
/**
 * Main CSS styles for UVE application
 */

/* Reset default styles */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body, html {
  height: 100%;
  width: 100%;
  font-family: Arial, sans-serif;
  overflow: hidden;
}

/* Main layout */
.app-container {
  display: flex;
  height: 100vh;
  width: 100vw;
}

.view-container {
  flex: 1;
  position: relative;
  height: 100%;
}

.view-divider {
  width: 6px;
  background-color: #333;
  cursor: col-resize;
  position: relative;
}

.view-divider::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 40px;
  background-color: #444;
  border-radius: 3px;
}

/* Three.js view styles */
#three-view-container {
  background-color: #111;
}

/* RDF view styles */
#rdf-view-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: #f5f5f5;
}

.rdf-view-toolbar {
  display: flex;
  padding: 10px;
  background-color: #2c3e50;
  color: white;
}

.rdf-view-toolbar button {
  margin-right: 10px;
  padding: 5px 10px;
  border: none;
  background-color: #3498db;
  color: white;
  border-radius: 3px;
  cursor: pointer;
}

.rdf-view-toolbar button:hover {
  background-color: #2980b9;
}

.rdf-view-toolbar select {
  padding: 5px;
  border: none;
  border-radius: 3px;
}

.rdf-view-editor {
  flex: 1;
  font-family: monospace;
  font-size: 14px;
  padding: 10px;
  border: none;
  resize: none;
  white-space: pre;
  tab-size: 2;
  background-color: #282c34;
  color: #abb2bf;
}

.rdf-view-status {
  display: flex;
  justify-content: space-between;
  padding: 5px 10px;
  background-color: #ecf0f1;
  border-top: 1px solid #bdc3c7;
}

.rdf-view-status.success::before {
  content: attr(data-message);
  color: #27ae60;
}

.rdf-view-status.error::before {
  content: attr(data-message);
  color: #e74c3c;
}

.rdf-view-count {
  color: #7f8c8d;
}

/* Navigation buttons */
.enter-class-button,
.exit-class-button {
  position: absolute;
  bottom: 20px;
  right: 20px;
  padding: 10px 15px;
  background-color: rgba(52, 152, 219, 0.8);
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  z-index: 1000;
  transition: background-color 0.3s ease;
}

.enter-class-button:hover,
.exit-class-button:hover {
  background-color: rgba(41, 128, 185, 0.9);
}

.hidden {
  display: none;
}

/* Info panel for selected objects */
.info-panel {
  position: absolute;
  top: 20px;
  right: 20px;
  width: 300px;
  background-color: rgba(44, 62, 80, 0.8);
  color: white;
  border-radius: 5px;
  padding: 15px;
  font-size: 14px;
  z-index: 1000;
  max-height: 80vh;
  overflow-y: auto;
}

.info-panel h3 {
  margin-bottom: 10px;
  font-size: 18px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  padding-bottom: 5px;
}

.info-panel h4 {
  margin: 10px 0 5px;
  font-size: 16px;
}

.info-panel p {
  margin-bottom: 8px;
}

.info-panel ul {
  margin-left: 20px;
}

.info-panel li {
  margin-bottom: 5px;
}

/* Loading indicator */
.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 5px solid #f3f3f3;
  border-top: 5px solid #3498db;
  border-radius: 50%;
  animation: spin 2s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Context menu */
.context-menu {
  position: absolute;
  background-color: white;
  border: 1px solid #ccc;
  border-radius: 3px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  padding: 5px 0;
  min-width: 150px;
  z-index: 1001;
}

.context-menu-item {
  padding: 8px 15px;
  cursor: pointer;
}

.context-menu-item:hover {
  background-color: #f2f2f2;
}

/* Help tooltip */
.help-tooltip {
  position: absolute;
  bottom: 20px;
  left: 20px;
  background-color: rgba(44, 62, 80, 0.8);
  color: white;
  border-radius: 5px;
  padding: 10px 15px;
  font-size: 14px;
  max-width: 300px;
  z-index: 1000;
}

.help-tooltip h4 {
  margin-bottom: 5px;
}

.help-tooltip p {
  margin-bottom: 5px;
}

.help-tooltip kbd {
  background-color: rgba(255, 255, 255, 0.2);
  padding: 2px 5px;
  border-radius: 3px;
  font-size: 12px;
}

================
File: src/util/fsStorageService.js
================
/**
 * FileSystem-based storage service implementation
 * @module util/fsStorageService
 */

import StorageService from './storageService.js';
import mockFs from './mockFs.js';

/**
 * Storage service implementation using filesystem (mock or real)
 */
class FSStorageService extends StorageService {
    /**
     * Create a new FSStorageService
     * @param {Object} [fs=mockFs] - Filesystem module to use (defaults to mockFs)
     * @param {string} [basePath=''] - Base path for all storage operations
     */
    constructor(fs = mockFs, basePath = '') {
        super();
        this.fs = fs;
        this.basePath = basePath.endsWith('/') ? basePath : basePath + '/';
    }

    /**
     * Get full path for a resource ID
     * @param {string} id - Resource identifier
     * @returns {string} Full path
     * @private
     */
    _getPath(id) {
        return this.basePath + id;
    }

    /**
     * Read data by ID
     * @async
     * @param {string} id - Resource identifier
     * @param {Object} [options={}] - Options for reading
     * @param {string} [options.encoding] - Encoding to use (e.g., 'utf8')
     * @returns {Promise<string|Uint8Array>} The retrieved data
     */
    async read(id, options = {}) {
        const path = this._getPath(id);
        return await this.fs.readFile(path, options);
    }

    /**
     * Write data with ID
     * @async
     * @param {string} id - Resource identifier
     * @param {string|Object|Uint8Array} data - Data to write
     * @param {Object} [options={}] - Options for writing
     * @returns {Promise<void>}
     */
    async write(id, data, options = {}) {
        const path = this._getPath(id);

        // Ensure parent directories exist
        if (id.includes('/')) {
            const dirPath = id.substring(0, id.lastIndexOf('/'));
            await this.fs.mkdir(this.basePath + dirPath, { recursive: true });
        }

        // Convert object to JSON string if it's an object
        if (typeof data === 'object' && !(data instanceof Uint8Array)) {
            data = JSON.stringify(data);
        }

        return await this.fs.writeFile(path, data, options);
    }

    /**
     * Delete data by ID
     * @async
     * @param {string} id - Resource identifier
     * @param {Object} [options={}] - Options for deletion
     * @returns {Promise<void>}
     */
    async delete(id, options = {}) {
        const path = this._getPath(id);
        return await this.fs.unlink(path);
    }

    /**
     * List available resources
     * @async
     * @param {string} [path=''] - Optional path/prefix to filter resources
     * @param {Object} [options={}] - Listing options
     * @returns {Promise<string[]>} Array of resource identifiers
     */
    async list(path = '', options = {}) {
        const dirPath = this._getPath(path);

        // Check if directory exists
        if (!(await this.fs.isDirectory(dirPath))) {
            return [];
        }

        const files = await this.fs.readdir(dirPath);

        // Map full paths back to resource IDs
        return files.map(file => {
            const fullPath = path ? `${path}/${file}` : file;
            return fullPath;
        });
    }

    /**
     * Query data with filters
     * @async
     * @param {Object} filters - Query filters
     * @param {Object} [options={}] - Query options
     * @returns {Promise<Object[]>} Array of matching resources
     */
    async query(filters, options = {}) {
        // Simple implementation: list all files in the given path and filter in-memory
        const path = filters.path || '';
        const resources = await this.list(path, options);

        const results = [];
        for (const id of resources) {
            try {
                // Try to read as JSON by default
                const data = await this.read(id, { encoding: 'utf8' });

                try {
                    const parsedData = JSON.parse(data);

                    // Check if the data matches all filters
                    let matches = true;
                    for (const [key, value] of Object.entries(filters)) {
                        if (key !== 'path' && (!parsedData[key] || parsedData[key] !== value)) {
                            matches = false;
                            break;
                        }
                    }

                    if (matches) {
                        results.push({
                            id,
                            data: parsedData
                        });
                    }
                } catch (e) {
                    // Not valid JSON, skip this file
                    continue;
                }
            } catch (e) {
                // Error reading file, skip it
                continue;
            }
        }

        return results;
    }
}

export default FSStorageService;

================
File: src/util/idGenerator.js
================
/**
 * Utility for generating unique IDs
 * @module util/idGenerator
 */

/**
 * Generate a unique ID with an optional prefix
 * @param {string} [prefix='id'] - Prefix for the ID
 * @returns {string} Unique ID
 */
function generateId(prefix = 'id') {
  return `${prefix}-${Math.random().toString(36).substring(2, 11)}`;
}

/**
 * Generate a unique URI for UVE namespace
 * @param {string} localName - Local part of the URI
 * @returns {string} Full URI string
 */
function generateUveUri(localName) {
  return `http://uve.example.org/ns#${localName}`;
}

/**
 * Generate a unique blank node ID
 * @returns {string} Blank node ID
 */
function generateBlankNodeId() {
  return `b${Date.now().toString(36)}${Math.random().toString(36).substring(2, 7)}`;
}

export {
  generateId,
  generateUveUri,
  generateBlankNodeId
};

================
File: src/util/initFs.js
================
/**
 * Initialize global window.fs for early access
 * This ensures window.fs is available before storageManager is fully initialized
 * @module util/initFs
 */

import mockFs from './mockFs.js';

// Initialize window.fs with mock implementation
if (typeof window !== 'undefined' && !window.fs) {
    window.fs = {
        readFile: mockFs.readFile,
        writeFile: mockFs.writeFile,
        unlink: mockFs.unlink,
        exists: mockFs.exists,
        readdir: mockFs.readdir,
        // Expose mock state for debugging
        _isMock: true
    };

    console.log('window.fs initialized with mock implementation');
}

export default {};

================
File: src/util/mockFs.js
================
/**
 * Mock filesystem module for browser environments
 * Simulates Node.js fs API operations in memory
 * @module util/mockFs
 */

// In-memory storage for files
const fileStorage = new Map();

/**
 * Read a file from the mock filesystem
 * @async
 * @param {string} path - File path
 * @param {Object} [options] - Options object
 * @param {string} [options.encoding] - File encoding (e.g., 'utf8')
 * @returns {Promise<Uint8Array|string>} File contents as Uint8Array or string if encoding specified
 */
async function readFile(path, options = {}) {
    if (!fileStorage.has(path)) {
        throw new Error(`ENOENT: no such file or directory, open '${path}'`);
    }

    const content = fileStorage.get(path);

    // If encoding is specified, return as string
    if (options.encoding) {
        return content;
    }

    // Otherwise return as Uint8Array (default behavior)
    const encoder = new TextEncoder();
    return encoder.encode(content);
}

/**
 * Write data to a file in the mock filesystem
 * @async
 * @param {string} path - File path
 * @param {string|Uint8Array} data - Data to write
 * @param {Object} [options] - Options object
 * @returns {Promise<void>}
 */
async function writeFile(path, data, options = {}) {
    // If data is Uint8Array, convert to string
    if (data instanceof Uint8Array) {
        const decoder = new TextDecoder();
        data = decoder.decode(data);
    }

    fileStorage.set(path, data);
    return Promise.resolve();
}

/**
 * Delete a file from the mock filesystem
 * @async
 * @param {string} path - File path
 * @returns {Promise<void>}
 */
async function unlink(path) {
    if (!fileStorage.has(path)) {
        throw new Error(`ENOENT: no such file or directory, unlink '${path}'`);
    }

    fileStorage.delete(path);
    return Promise.resolve();
}

/**
 * Check if a file exists in the mock filesystem
 * @async
 * @param {string} path - File path
 * @returns {Promise<boolean>} True if file exists
 */
async function exists(path) {
    return Promise.resolve(fileStorage.has(path));
}

/**
 * List files in a directory in the mock filesystem
 * @async
 * @param {string} path - Directory path
 * @returns {Promise<string[]>} Array of file names
 */
async function readdir(path) {
    // Normalize path to end with a slash
    const dirPath = path.endsWith('/') ? path : path + '/';

    // Find all files that start with the directory path
    const files = [];
    for (const filePath of fileStorage.keys()) {
        if (filePath.startsWith(dirPath)) {
            // Extract the relative path inside the directory
            const relativePath = filePath.slice(dirPath.length);
            // Only include direct children (no subdirectories)
            if (!relativePath.includes('/')) {
                files.push(relativePath);
            }
        }
    }

    return Promise.resolve(files);
}

/**
 * Check if path is a directory
 * @async
 * @param {string} path - Path to check
 * @returns {Promise<boolean>} True if path is a directory
 */
async function isDirectory(path) {
    // In our mock fs, we consider a path a directory if any file path starts with it
    const dirPath = path.endsWith('/') ? path : path + '/';

    for (const filePath of fileStorage.keys()) {
        if (filePath.startsWith(dirPath)) {
            return Promise.resolve(true);
        }
    }

    return Promise.resolve(false);
}

/**
 * Create a new directory
 * @async
 * @param {string} path - Directory path
 * @returns {Promise<void>}
 */
async function mkdir(path) {
    // Directories don't need actual entries in our mock filesystem
    return Promise.resolve();
}

/**
 * Clear all files from the mock filesystem (useful for testing)
 */
function reset() {
    fileStorage.clear();
}

// Export the mock fs API
export default {
    readFile,
    writeFile,
    unlink,
    exists,
    readdir,
    isDirectory,
    mkdir,
    reset,
    // Add this property to help identify this as a mock
    isMockFs: true
};

================
File: src/util/sparqlStorageService.js
================
/**
 * SPARQL-based storage service implementation
 * @module util/sparqlStorageService
 */

import StorageService from './storageService.js';

/**
 * Storage service implementation using SPARQL endpoint
 */
class SPARQLStorageService extends StorageService {
    /**
     * Create a new SPARQLStorageService
     * @param {string} endpoint - SPARQL endpoint URL
     * @param {string} [graphUri=''] - Default graph URI to use
     * @param {Object} [options={}] - Additional options
     * @param {Object} [options.headers={}] - HTTP headers to include in requests
     * @param {number} [options.timeout=30000] - Request timeout in milliseconds
     * @param {string} [options.prefix='uve:'] - Prefix for UVE resources
     */
    constructor(endpoint, graphUri = '', options = {}) {
        super();
        this.endpoint = endpoint;
        this.graphUri = graphUri;
        this.headers = options.headers || {};
        this.timeout = options.timeout || 30000;
        this.prefix = options.prefix || 'uve:';

        // Set default headers
        this.headers = {
            'Accept': 'application/sparql-results+json,application/json',
            'Content-Type': 'application/x-www-form-urlencoded',
            ...this.headers
        };
    }

    /**
     * Convert resource ID to URI
     * @param {string} id - Resource identifier
     * @returns {string} Full URI for the resource
     * @private
     */
    _getResourceUri(id) {
        // If already a URI (starts with http), return as is
        if (id.startsWith('http://') || id.startsWith('https://')) {
            return `<${id}>`;
        }

        // Otherwise, prefix with the UVE namespace
        return `${this.prefix}${id}`;
    }

    /**
     * Execute a SPARQL query
     * @async
     * @param {string} query - SPARQL query to execute
     * @param {boolean} [isUpdate=false] - Whether this is an update query
     * @returns {Promise<Object>} Query results
     * @private
     */
    async _executeSparql(query, isUpdate = false) {
        const params = new URLSearchParams();

        if (isUpdate) {
            params.append('update', query);
        } else {
            params.append('query', query);
        }

        try {
            const response = await fetch(this.endpoint, {
                method: 'POST',
                headers: this.headers,
                body: params.toString(),
                timeout: this.timeout
            });

            if (!response.ok) {
                throw new Error(`SPARQL request failed: ${response.status} ${response.statusText}`);
            }

            // For update operations, we don't need to parse the response
            if (isUpdate) {
                return { success: true };
            }

            return await response.json();
        } catch (error) {
            console.error('SPARQL query error:', error);
            throw error;
        }
    }

    /**
     * Read data by ID
     * @async
     * @param {string} id - Resource identifier
     * @param {Object} [options={}] - Options for reading
     * @param {string} [options.format='object'] - Format to return: 'object', 'turtle', 'n-triples'
     * @returns {Promise<Object|string>} The retrieved data
     */
    async read(id, options = {}) {
        const resourceUri = this._getResourceUri(id);
        const format = options.format || 'object';

        let query;
        if (this.graphUri) {
            query = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        CONSTRUCT { ?s ?p ?o }
        FROM <${this.graphUri}>
        WHERE {
          ?s ?p ?o .
          FILTER(?s = ${resourceUri})
        }
      `;
        } else {
            query = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        CONSTRUCT { ?s ?p ?o }
        WHERE {
          ?s ?p ?o .
          FILTER(?s = ${resourceUri})
        }
      `;
        }

        // Override headers for this request to get the right format
        const originalAccept = this.headers['Accept'];

        try {
            if (format === 'turtle') {
                this.headers['Accept'] = 'text/turtle';
            } else if (format === 'n-triples') {
                this.headers['Accept'] = 'application/n-triples';
            } else {
                this.headers['Accept'] = 'application/ld+json';
            }

            const result = await this._executeSparql(query);

            if (format === 'object' && typeof result === 'string') {
                // Parse JSON-LD to a simpler object structure
                return this._simplifyJsonLd(JSON.parse(result));
            }

            return result;
        } finally {
            // Restore original Accept header
            this.headers['Accept'] = originalAccept;
        }
    }

    /**
     * Write data with ID
     * @async
     * @param {string} id - Resource identifier
     * @param {Object|string} data - Data to write (object or serialized RDF)
     * @param {Object} [options={}] - Options for writing
     * @param {string} [options.format='object'] - Format of input data: 'object', 'turtle', 'n-triples'
     * @returns {Promise<void>}
     */
    async write(id, data, options = {}) {
        const resourceUri = this._getResourceUri(id);
        const format = options.format || 'object';

        // First, delete any existing triples for this resource
        await this.delete(id);

        let insertQuery;

        if (format === 'object') {
            // Convert object to SPARQL INSERT statements
            const triples = this._objectToTriples(id, data);

            if (this.graphUri) {
                insertQuery = `
          INSERT DATA {
            GRAPH <${this.graphUri}> {
              ${triples}
            }
          }
        `;
            } else {
                insertQuery = `
          INSERT DATA {
            ${triples}
          }
        `;
            }
        } else if (format === 'turtle' || format === 'n-triples') {
            // Data is already in RDF format, use LOAD or equivalent
            // This is a simplified approach; in practice, you might need
            // to use a different method like uploading directly to a triple store

            if (this.graphUri) {
                insertQuery = `
          INSERT DATA {
            GRAPH <${this.graphUri}> {
              ${data}
            }
          }
        `;
            } else {
                insertQuery = `
          INSERT DATA {
            ${data}
          }
        `;
            }
        } else {
            throw new Error(`Unsupported format: ${format}`);
        }

        await this._executeSparql(insertQuery, true);
    }

    /**
     * Delete data by ID
     * @async
     * @param {string} id - Resource identifier
     * @param {Object} [options={}] - Options for deletion
     * @returns {Promise<void>}
     */
    async delete(id, options = {}) {
        const resourceUri = this._getResourceUri(id);

        let deleteQuery;
        if (this.graphUri) {
            deleteQuery = `
        DELETE WHERE {
          GRAPH <${this.graphUri}> {
            ${resourceUri} ?p ?o .
          }
        }
      `;
        } else {
            deleteQuery = `
        DELETE WHERE {
          ${resourceUri} ?p ?o .
        }
      `;
        }

        await this._executeSparql(deleteQuery, true);
    }

    /**
     * List available resources
     * @async
     * @param {string} [type=''] - Optional RDF type to filter resources
     * @param {Object} [options={}] - Listing options
     * @returns {Promise<string[]>} Array of resource identifiers
     */
    async list(type = '', options = {}) {
        let typeFilter = '';
        if (type) {
            const typeUri = this._getResourceUri(type);
            typeFilter = `
        ?s rdf:type ${typeUri} .
      `;
        }

        let query;
        if (this.graphUri) {
            query = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        SELECT DISTINCT ?s
        FROM <${this.graphUri}>
        WHERE {
          ?s ?p ?o .
          ${typeFilter}
        }
      `;
        } else {
            query = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        SELECT DISTINCT ?s
        WHERE {
          ?s ?p ?o .
          ${typeFilter}
        }
      `;
        }

        const result = await this._executeSparql(query);

        // Extract resource URIs from results
        const resources = [];
        if (result.results && result.results.bindings) {
            for (const binding of result.results.bindings) {
                if (binding.s && binding.s.value) {
                    resources.push(this._uriToId(binding.s.value));
                }
            }
        }

        return resources;
    }

    /**
     * Query data with filters
     * @async
     * @param {Object} filters - Query filters
     * @param {Object} [options={}] - Query options
     * @returns {Promise<Object[]>} Array of matching resources
     */
    async query(filters, options = {}) {
        // Convert filters to SPARQL patterns
        const patterns = [];
        const filterValues = [];

        for (const [key, value] of Object.entries(filters)) {
            const varName = `?${key}`;
            const propUri = this._getResourceUri(key);

            patterns.push(`?s ${propUri} ${varName} .`);

            if (value !== undefined) {
                // Add a FILTER for this value
                if (typeof value === 'string') {
                    filterValues.push(`FILTER(${varName} = "${value}")`);
                } else if (typeof value === 'number') {
                    filterValues.push(`FILTER(${varName} = ${value})`);
                } else if (typeof value === 'boolean') {
                    filterValues.push(`FILTER(${varName} = ${value})`);
                }
            }
        }

        let query;
        if (this.graphUri) {
            query = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        SELECT ?s
        FROM <${this.graphUri}>
        WHERE {
          ${patterns.join('\n  ')}
          ${filterValues.join('\n  ')}
        }
      `;
        } else {
            query = `
        PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        SELECT ?s
        WHERE {
          ${patterns.join('\n  ')}
          ${filterValues.join('\n  ')}
        }
      `;
        }

        const result = await this._executeSparql(query);

        // Fetch full data for each matching resource
        const resources = [];
        if (result.results && result.results.bindings) {
            for (const binding of result.results.bindings) {
                if (binding.s && binding.s.value) {
                    const id = this._uriToId(binding.s.value);
                    const data = await this.read(id);
                    resources.push({
                        id,
                        data
                    });
                }
            }
        }

        return resources;
    }

    /**
     * Convert URI to resource ID
     * @param {string} uri - Resource URI
     * @returns {string} Resource ID
     * @private
     */
    _uriToId(uri) {
        // If using the UVE prefix, remove it
        if (this.prefix && uri.startsWith(this.prefix)) {
            return uri.substring(this.prefix.length);
        }

        // Otherwise return the full URI
        return uri;
    }

    /**
     * Convert object to SPARQL triples
     * @param {string} id - Resource ID
     * @param {Object} obj - Object to convert
     * @returns {string} SPARQL triples
     * @private
     */
    _objectToTriples(id, obj) {
        const resourceUri = this._getResourceUri(id);
        const triples = [];

        for (const [key, value] of Object.entries(obj)) {
            const predicate = this._getResourceUri(key);

            if (Array.isArray(value)) {
                // Handle arrays
                for (const item of value) {
                    triples.push(this._createTriple(resourceUri, predicate, item));
                }
            } else {
                // Handle single values
                triples.push(this._createTriple(resourceUri, predicate, value));
            }
        }

        return triples.join('\n');
    }

    /**
     * Create a single SPARQL triple
     * @param {string} subject - Subject URI
     * @param {string} predicate - Predicate URI
     * @param {string|number|boolean|Object} object - Object value
     * @returns {string} SPARQL triple
     * @private
     */
    _createTriple(subject, predicate, object) {
        if (typeof object === 'string') {
            // Check if it looks like a URI
            if (object.startsWith('http://') || object.startsWith('https://')) {
                return `${subject} ${predicate} <${object}> .`;
            } else {
                return `${subject} ${predicate} "${object}" .`;
            }
        } else if (typeof object === 'number') {
            return `${subject} ${predicate} ${object} .`;
        } else if (typeof object === 'boolean') {
            return `${subject} ${predicate} "${object}"^^<http://www.w3.org/2001/XMLSchema#boolean> .`;
        } else if (object === null) {
            // Skip null values
            return '';
        } else if (typeof object === 'object') {
            // Nested objects not supported in this simple implementation
            console.warn('Nested objects not supported in SPARQL conversion:', object);
            return '';
        }

        return '';
    }

    /**
     * Simplify JSON-LD to a more usable object structure
     * @param {Object} jsonld - JSON-LD data
     * @returns {Object} Simplified object
     * @private
     */
    _simplifyJsonLd(jsonld) {
        // Very basic JSON-LD simplification
        // In a real implementation, you would use a proper JSON-LD processor

        // If it's an array with a single object, extract it
        if (Array.isArray(jsonld) && jsonld.length === 1) {
            jsonld = jsonld[0];
        }

        const result = {};

        // Process all properties
        for (const [key, value] of Object.entries(jsonld)) {
            // Skip @context, @id, etc.
            if (key.startsWith('@')) {
                continue;
            }

            if (Array.isArray(value)) {
                result[key] = value.map(item => {
                    if (item['@value']) {
                        return item['@value'];
                    } else if (item['@id']) {
                        return item['@id'];
                    } else {
                        return this._simplifyJsonLd(item);
                    }
                });
            } else if (typeof value === 'object') {
                if (value['@value']) {
                    result[key] = value['@value'];
                } else if (value['@id']) {
                    result[key] = value['@id'];
                } else {
                    result[key] = this._simplifyJsonLd(value);
                }
            } else {
                result[key] = value;
            }
        }

        return result;
    }
}

export default SPARQLStorageService;

================
File: src/util/storageManager.js
================
/**
 * Storage manager for UVE
 * Provides a unified interface for storage operations
 * @module util/storageManager
 */

import FSStorageService from './fsStorageService.js';
import SPARQLStorageService from './sparqlStorageService.js';
import mockFs from './mockFs.js';
import log from 'loglevel';
import config from '../core/config.js';

/**
 * Storage manager singleton
 */
class StorageManager {
    /**
     * Create a new StorageManager
     */
    constructor() {
        this.log = log.getLogger('StorageManager');
        this.storageServices = new Map();
        this.defaultService = null;

        // Initialize with filesystem storage by default
        this.setupDefaultStorage();
    }

    /**
     * Set up default storage service based on config
     */
    setupDefaultStorage() {
        const storageConfig = config.storage || {};
        const storageType = storageConfig.type || 'fs';

        if (storageType === 'sparql') {
            const endpoint = storageConfig.endpoint || 'http://localhost:3030/uve/sparql';
            const graphUri = storageConfig.graphUri || '';

            this.log.info(`Setting up SPARQL storage with endpoint: ${endpoint}`);

            const sparqlService = new SPARQLStorageService(endpoint, graphUri, {
                prefix: storageConfig.prefix || 'http://uve.example.org/resource/',
                headers: storageConfig.headers || {}
            });

            this.registerService('default', sparqlService);
            this.setDefaultService('default');
        } else {
            this.log.info('Setting up filesystem storage');

            const fsService = new FSStorageService(mockFs, storageConfig.basePath || '');
            this.registerService('default', fsService);
            this.setDefaultService('default');
        }

        // Set up the window.fs object for backward compatibility
        if (typeof window !== 'undefined') {
            window.fs = {
                readFile: this.readFile.bind(this),
                writeFile: this.writeFile.bind(this),
                unlink: this.delete.bind(this),
                exists: this.exists.bind(this),
                readdir: this.list.bind(this)
            };
        }
    }

    /**
     * Register a storage service
     * @param {string} name - Service name
     * @param {StorageService} service - Storage service instance
     */
    registerService(name, service) {
        this.storageServices.set(name, service);
        this.log.debug(`Registered storage service: ${name}`);

        // Set as default if no default is set
        if (!this.defaultService) {
            this.setDefaultService(name);
        }
    }

    /**
     * Set the default storage service
     * @param {string} name - Service name
     */
    setDefaultService(name) {
        if (!this.storageServices.has(name)) {
            throw new Error(`Storage service not found: ${name}`);
        }

        this.defaultService = name;
        this.log.info(`Set default storage service: ${name}`);
    }

    /**
     * Get a storage service by name
     * @param {string} [name] - Service name (uses default if not specified)
     * @returns {StorageService} Storage service
     */
    getService(name) {
        const serviceName = name || this.defaultService;

        if (!this.storageServices.has(serviceName)) {
            throw new Error(`Storage service not found: ${serviceName}`);
        }

        return this.storageServices.get(serviceName);
    }

    /**
     * Read a file (compatible with fs API)
     * @async
     * @param {string} path - File path
     * @param {Object} [options] - Options object
     * @returns {Promise<Uint8Array|string>} File contents
     */
    async readFile(path, options = {}) {
        try {
            const service = this.getService();
            return await service.read(path, options);
        } catch (error) {
            this.log.error(`Error reading file ${path}:`, error);
            throw error;
        }
    }

    /**
     * Write a file (compatible with fs API)
     * @async
     * @param {string} path - File path
     * @param {string|Uint8Array} data - Data to write
     * @param {Object} [options] - Options object
     * @returns {Promise<void>}
     */
    async writeFile(path, data, options = {}) {
        try {
            const service = this.getService();
            return await service.write(path, data, options);
        } catch (error) {
            this.log.error(`Error writing file ${path}:`, error);
            throw error;
        }
    }

    /**
     * Delete a file (compatible with fs API)
     * @async
     * @param {string} path - File path
     * @returns {Promise<void>}
     */
    async delete(path) {
        try {
            const service = this.getService();
            return await service.delete(path);
        } catch (error) {
            this.log.error(`Error deleting file ${path}:`, error);
            throw error;
        }
    }

    /**
     * Check if a file exists (compatible with fs API)
     * @async
     * @param {string} path - File path
     * @returns {Promise<boolean>} True if file exists
     */
    async exists(path) {
        try {
            const service = this.getService();
            const data = await service.read(path);
            return true;
        } catch (error) {
            return false;
        }
    }

    /**
     * List files in a directory (compatible with fs API)
     * @async
     * @param {string} path - Directory path
     * @returns {Promise<string[]>} Array of file names
     */
    async list(path = '') {
        try {
            const service = this.getService();
            return await service.list(path);
        } catch (error) {
            this.log.error(`Error listing files in ${path}:`, error);
            throw error;
        }
    }

    /**
     * Query data with filters
     * @async
     * @param {Object} filters - Query filters
     * @param {Object} [options] - Query options
     * @returns {Promise<Object[]>} Array of matching resources
     */
    async query(filters, options = {}) {
        try {
            const service = this.getService();
            return await service.query(filters, options);
        } catch (error) {
            this.log.error(`Error querying with filters:`, error);
            throw error;
        }
    }
}

// Export a singleton instance
const storageManager = new StorageManager();
export default storageManager;

================
File: src/util/storageService.js
================
/**
 * Storage service interface for UVE
 * Defines a common interface for different storage backends
 * @module util/storageService
 */

/**
 * Abstract base class for storage services
 * @abstract
 */
class StorageService {
    /**
     * Read data by ID
     * @async
     * @param {string} id - Resource identifier
     * @param {Object} [options] - Options for reading
     * @returns {Promise<string|Object|Uint8Array>} The retrieved data
     * @abstract
     */
    async read(id, options = {}) {
        throw new Error('Method not implemented');
    }

    /**
     * Write data with ID
     * @async
     * @param {string} id - Resource identifier
     * @param {string|Object|Uint8Array} data - Data to write
     * @param {Object} [options] - Options for writing
     * @returns {Promise<void>}
     * @abstract
     */
    async write(id, data, options = {}) {
        throw new Error('Method not implemented');
    }

    /**
     * Delete data by ID
     * @async
     * @param {string} id - Resource identifier
     * @param {Object} [options] - Options for deletion
     * @returns {Promise<void>}
     * @abstract
     */
    async delete(id, options = {}) {
        throw new Error('Method not implemented');
    }

    /**
     * List available resources
     * @async
     * @param {string} [path] - Optional path/prefix to filter resources
     * @param {Object} [options] - Listing options
     * @returns {Promise<string[]>} Array of resource identifiers
     * @abstract
     */
    async list(path = '', options = {}) {
        throw new Error('Method not implemented');
    }

    /**
     * Query data with filters
     * @async
     * @param {Object} filters - Query filters
     * @param {Object} [options] - Query options
     * @returns {Promise<Object[]>} Array of matching resources
     * @abstract
     */
    async query(filters, options = {}) {
        throw new Error('Method not implemented');
    }
}

export default StorageService;

================
File: src/view/rdfView/rdfFileView.js
================
/**
 * RDFFileView provides a view for RDF data in Turtle syntax
 * @module view/rdfView/rdfFileView
 */

import log from 'loglevel';
import formatsPretty from '@rdfjs/formats/pretty.js';
import rdf from 'rdf-ext';
import eventBus from '../../core/eventBus.js';
import storageManager from '../../util/storageManager.js';

class RDFFileView {
  /**
   * Create a new RDFFileView
   * @param {RDFModel} rdfModel - RDF data model
   * @param {HTMLElement} container - DOM element to render into
   */
  constructor(rdfModel, container) {
    this.rdfModel = rdfModel;
    this.container = container;
    this.log = log.getLogger('RDFFileView');

    // Setup pretty formatters
    this.prettyRdf = rdf.clone();
    this.prettyRdf.formats.import(formatsPretty);

    // Create editor elements
    this.createEditor();

    // Subscribe to RDF model changes
    eventBus.subscribe('rdf-model-changed', data => this.updateView(data));
  }

  /**
   * Create the editor elements
   */
  createEditor() {
    // Create toolbar
    this.toolbar = document.createElement('div');
    this.toolbar.className = 'rdf-view-toolbar';
    this.container.appendChild(this.toolbar);

    // Create load button
    this.loadButton = document.createElement('button');
    this.loadButton.textContent = 'Load';
    this.loadButton.addEventListener('click', () => this.loadFromFile());
    this.toolbar.appendChild(this.loadButton);

    // Create save button
    this.saveButton = document.createElement('button');
    this.saveButton.textContent = 'Save';
    this.saveButton.addEventListener('click', () => this.saveToFile());
    this.toolbar.appendChild(this.saveButton);

    // Create format selector
    this.formatSelector = document.createElement('select');

    const formats = [
      { value: 'text/turtle', label: 'Turtle' },
      { value: 'application/n-triples', label: 'N-Triples' },
      { value: 'application/n-quads', label: 'N-Quads' },
      { value: 'application/trig', label: 'TriG' },
      { value: 'application/ld+json', label: 'JSON-LD' }
    ];

    formats.forEach(format => {
      const option = document.createElement('option');
      option.value = format.value;
      option.textContent = format.label;
      this.formatSelector.appendChild(option);
    });

    this.formatSelector.addEventListener('change', () => this.updateView());
    this.toolbar.appendChild(this.formatSelector);

    // Create editor element
    this.editor = document.createElement('textarea');
    this.editor.className = 'rdf-view-editor';
    this.editor.spellcheck = false;
    this.container.appendChild(this.editor);

    // Create status bar
    this.statusBar = document.createElement('div');
    this.statusBar.className = 'rdf-view-status';
    this.container.appendChild(this.statusBar);

    // Apply button - to apply changes from editor to model
    this.applyButton = document.createElement('button');
    this.applyButton.textContent = 'Apply Changes';
    this.applyButton.addEventListener('click', () => this.applyChanges());
    this.statusBar.appendChild(this.applyButton);

    // Triple count
    this.tripleCount = document.createElement('span');
    this.tripleCount.className = 'rdf-view-count';
    this.statusBar.appendChild(this.tripleCount);
  }

  /**
   * Update the view with the current RDF model
   * @param {Object} [data] - Change data from event
   */
  async updateView(data) {
    this.log.debug('Updating RDF view', data);

    try {
      // Get selected format
      const format = this.formatSelector.value;

      // Serialize dataset to text
      const serialized = await this.prettyRdf.io.dataset.toText(format, this.rdfModel.dataset);

      // Update editor
      this.editor.value = serialized;

      // Update triple count
      this.tripleCount.textContent = `${this.rdfModel.dataset.size} triples`;
    } catch (error) {
      this.log.error('Error updating RDF view:', error);
      this.showError('Error updating view: ' + error.message);
    }
  }

  /**
   * Apply changes from editor to model
   */
  async applyChanges() {
    try {
      // Get text from editor
      const text = this.editor.value;

      // Get selected format
      const format = this.formatSelector.value;

      // Parse text to dataset
      const dataset = await this.prettyRdf.io.dataset.fromText(format, text);

      // Clear existing dataset and add new triples
      this.rdfModel.dataset.deleteMatches();
      this.rdfModel.dataset.addAll(dataset);

      // Notify change
      eventBus.publish('rdf-model-changed', { source: 'editor' });

      this.log.info(`Applied changes: ${dataset.size} triples`);
      this.showSuccess(`Applied ${dataset.size} triples`);
    } catch (error) {
      this.log.error('Error applying changes:', error);
      this.showError('Error applying changes: ' + error.message);
    }
  }

  /**
   * Load RDF data from a file
   */
  loadFromFile() {
    // Create file input
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.ttl,.nt,.nq,.trig,.jsonld,.json';

    // Handle file selection
    fileInput.addEventListener('change', async event => {
      const file = event.target.files[0];

      if (!file) return;

      try {
        // Determine format from file extension
        const format = this.getFormatFromFileName(file.name);

        // Read file content
        const text = await this.readFileAsText(file);

        // Parse text to dataset
        const dataset = await this.prettyRdf.io.dataset.fromText(format, text);

        // Store in localStorage for persistence
        const storageId = `rdf-file-${file.name}`;
        await storageManager.writeFile(storageId, text);

        // Clear existing dataset and add new triples
        this.rdfModel.dataset.deleteMatches();
        this.rdfModel.dataset.addAll(dataset);

        // Notify change
        eventBus.publish('rdf-model-changed', { source: 'file', path: file.name });

        this.log.info(`Loaded ${dataset.size} triples from ${file.name}`);
        this.showSuccess(`Loaded ${dataset.size} triples from ${file.name}`);

        // Select matching format in dropdown
        for (let i = 0; i < this.formatSelector.options.length; i++) {
          if (this.formatSelector.options[i].value === format) {
            this.formatSelector.selectedIndex = i;
            break;
          }
        }
      } catch (error) {
        this.log.error(`Error loading file ${file.name}:`, error);
        this.showError(`Error loading file: ${error.message}`);
      }
    });

    // Trigger file selection
    fileInput.click();
  }

  /**
   * Save RDF data to a file
   */
  async saveToFile() {
    try {
      // Get selected format
      const format = this.formatSelector.value;

      // Get file extension for the format
      const extension = this.getFileExtensionForFormat(format);

      // Serialize dataset to text
      const serialized = await this.prettyRdf.io.dataset.toText(format, this.rdfModel.dataset);

      // Store in storage manager
      const filename = `model${extension}`;
      const storageId = `rdf-file-${filename}`;
      await storageManager.writeFile(storageId, serialized);

      // For browser download, create a blob URL
      const blob = new Blob([serialized], { type: format });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;

      // Trigger download
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      // Clean up
      URL.revokeObjectURL(url);

      this.log.info(`Saved ${this.rdfModel.dataset.size} triples to ${filename}`);
      this.showSuccess(`Saved ${this.rdfModel.dataset.size} triples to ${filename}`);
    } catch (error) {
      this.log.error('Error saving file:', error);
      this.showError('Error saving file: ' + error.message);
    }
  }

  /**
   * Read a file as text
   * @param {File} file - File to read
   * @returns {Promise<string>} File contents as text
   */
  readFileAsText(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();

      reader.onload = event => {
        resolve(event.target.result);
      };

      reader.onerror = error => {
        reject(error);
      };

      reader.readAsText(file);
    });
  }

  /**
   * Get format from file name
   * @param {string} fileName - File name
   * @returns {string} MIME type for the file
   */
  getFormatFromFileName(fileName) {
    const extension = fileName.split('.').pop().toLowerCase();

    const formatMap = {
      ttl: 'text/turtle',
      nt: 'application/n-triples',
      nq: 'application/n-quads',
      trig: 'application/trig',
      jsonld: 'application/ld+json',
      json: 'application/ld+json'
    };

    return formatMap[extension] || 'text/turtle';
  }

  /**
   * Get file extension for format
   * @param {string} format - MIME type
   * @returns {string} File extension for the format
   */
  getFileExtensionForFormat(format) {
    const extensionMap = {
      'text/turtle': '.ttl',
      'application/n-triples': '.nt',
      'application/n-quads': '.nq',
      'application/trig': '.trig',
      'application/ld+json': '.jsonld'
    };

    return extensionMap[format] || '.ttl';
  }

  /**
   * Show a success message
   * @param {string} message - Success message
   */
  showSuccess(message) {
    this.statusBar.className = 'rdf-view-status success';
    this.statusBar.setAttribute('data-message', message);

    // Reset after 3 seconds
    setTimeout(() => {
      this.statusBar.className = 'rdf-view-status';
    }, 3000);
  }

  /**
   * Show an error message
   * @param {string} message - Error message
   */
  showError(message) {
    this.statusBar.className = 'rdf-view-status error';
    this.statusBar.setAttribute('data-message', message);

    // Reset after 5 seconds
    setTimeout(() => {
      this.statusBar.className = 'rdf-view-status';
    }, 5000);
  }
}

export default RDFFileView;

================
File: src/view/threeView/components/controls.js
================
/**
 * First-person controls for navigating the 3D space
 * @module view/threeView/controls
 */

import * as THREE from 'three';
import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
import config from '../../../core/config.js';
import eventBus from '../../../core/eventBus.js';

class Controls {
  /**
   * Create first-person controls
   * @param {THREE.Camera} camera - THREE.js camera
   * @param {HTMLElement} domElement - DOM element for pointer lock
   */
  constructor(camera, domElement) {
    this.camera = camera;
    this.domElement = domElement;
    
    // Create controls
    this.controls = new PointerLockControls(camera, domElement);
    
    // Set up movement
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    this.moveUp = false;
    this.moveDown = false;
    
    // Set up movement speed
    this.velocity = new THREE.Vector3();
    this.direction = new THREE.Vector3();
    this.movementSpeed = config.visualization.controls.movementSpeed;
    
    // Set up keyboard event handlers
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onKeyUp = this.onKeyUp.bind(this);
    
    // Set up click handler for locking controls
    this.onClick = this.onClick.bind(this);
    
    // Lock/unlock handler
    this.onLockChange = this.onLockChange.bind(this);
    
    // Set up event listeners
    document.addEventListener('keydown', this.onKeyDown);
    document.addEventListener('keyup', this.onKeyUp);
    this.domElement.addEventListener('click', this.onClick);
    document.addEventListener('pointerlockchange', this.onLockChange);
    
    // Raycast for interaction
    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2();
    
    // Setup mouse move handler for raycasting
    this.onMouseMove = this.onMouseMove.bind(this);
    document.addEventListener('mousemove', this.onMouseMove);
    
    // Track intersection objects
    this.intersectedObject = null;
    
    // Click handling for object interaction
    this.onObjectClick = this.onObjectClick.bind(this);
    document.addEventListener('click', this.onObjectClick);
    
    // Keep track of selected object
    this.selectedObject = null;
  }
  
  /**
   * Handle key down events
   * @param {KeyboardEvent} event - Key down event
   */
  onKeyDown(event) {
    // Only handle events when controls are locked
    if (!this.controls.isLocked) return;
    
    switch (event.code) {
      case 'ArrowUp':
      case 'KeyW':
        this.moveForward = true;
        break;
        
      case 'ArrowLeft':
      case 'KeyA':
        this.moveLeft = true;
        break;
        
      case 'ArrowDown':
      case 'KeyS':
        this.moveBackward = true;
        break;
        
      case 'ArrowRight':
      case 'KeyD':
        this.moveRight = true;
        break;
        
      case 'KeyQ':
        this.moveDown = true;
        break;
        
      case 'KeyE':
        this.moveUp = true;
        break;
    }
  }
  
  /**
   * Handle key up events
   * @param {KeyboardEvent} event - Key up event
   */
  onKeyUp(event) {
    switch (event.code) {
      case 'ArrowUp':
      case 'KeyW':
        this.moveForward = false;
        break;
        
      case 'ArrowLeft':
      case 'KeyA':
        this.moveLeft = false;
        break;
        
      case 'ArrowDown':
      case 'KeyS':
        this.moveBackward = false;
        break;
        
      case 'ArrowRight':
      case 'KeyD':
        this.moveRight = false;
        break;
        
      case 'KeyQ':
        this.moveDown = false;
        break;
        
      case 'KeyE':
        this.moveUp = false;
        break;
    }
  }
  
  /**
   * Handle click events for locking controls
   */
  onClick() {
    if (!this.controls.isLocked) {
      this.controls.lock();
    }
  }
  
  /**
   * Handle pointer lock change
   */
  onLockChange() {
    if (document.pointerLockElement === this.domElement) {
      eventBus.publish('controls-locked', true);
    } else {
      eventBus.publish('controls-locked', false);
    }
  }
  
  /**
   * Handle mouse move events for raycasting
   * @param {MouseEvent} event - Mouse move event
   */
  onMouseMove(event) {
    // Only perform raycasting when controls are not locked
    if (this.controls.isLocked) return;
    
    // Calculate mouse position in normalized device coordinates
    this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  }
  
  /**
   * Handle click events for object interaction
   * @param {MouseEvent} event - Click event
   */
  onObjectClick(event) {
    // Only handle clicks when controls are not locked
    if (this.controls.isLocked) return;
    
    // If we have an intersected object, handle the click
    if (this.intersectedObject) {
      const userData = this.intersectedObject.userData;
      
      // Clear previous selection if any
      if (this.selectedObject) {
        // Publish deselection event
        eventBus.publish('object-deselected', {
          type: this.selectedObject.userData.type,
          uri: this.selectedObject.userData.uri
        });
        
        this.selectedObject = null;
      }
      
      // Set new selection
      this.selectedObject = this.intersectedObject;
      
      // Publish selection event
      eventBus.publish('object-selected', {
        type: userData.type,
        uri: userData.uri,
        entity: userData.entity
      });
    } else {
      // Click on empty space - clear selection
      if (this.selectedObject) {
        // Publish deselection event
        eventBus.publish('object-deselected', {
          type: this.selectedObject.userData.type,
          uri: this.selectedObject.userData.uri
        });
        
        this.selectedObject = null;
      }
    }
  }
  
  /**
   * Update controls for the current frame
   * @param {number} deltaTime - Time since last frame in seconds
   * @param {THREE.Scene} scene - THREE.js scene
   */
  update(deltaTime, scene) {
    // Update movement if controls are locked
    if (this.controls.isLocked) {
      // Calculate velocity based on current movement direction
      this.velocity.x -= this.velocity.x * 10.0 * deltaTime;
      this.velocity.z -= this.velocity.z * 10.0 * deltaTime;
      this.velocity.y -= this.velocity.y * 10.0 * deltaTime;
      
      this.direction.z = Number(this.moveForward) - Number(this.moveBackward);
      this.direction.x = Number(this.moveRight) - Number(this.moveLeft);
      this.direction.y = Number(this.moveUp) - Number(this.moveDown);
      this.direction.normalize();
      
      if (this.moveForward || this.moveBackward) {
        this.velocity.z -= this.direction.z * this.movementSpeed * deltaTime;
      }
      
      if (this.moveLeft || this.moveRight) {
        this.velocity.x -= this.direction.x * this.movementSpeed * deltaTime;
      }
      
      if (this.moveUp || this.moveDown) {
        this.velocity.y += this.direction.y * this.movementSpeed * deltaTime;
      }
      
      // Move the camera
      this.controls.moveRight(-this.velocity.x);
      this.controls.moveForward(-this.velocity.z);
      this.camera.position.y += this.velocity.y;
    } else {
      // Perform raycasting for hover effects
      this.raycaster.setFromCamera(this.mouse, this.camera);
      
      // Find intersections
      const intersects = this.raycaster.intersectObjects(scene.children, true);
      
      // Reset intersected object
      if (this.intersectedObject) {
        // Handle hover out
        eventBus.publish('object-hover', {
          type: 'out',
          object: this.intersectedObject
        });
        
        this.intersectedObject = null;
      }
      
      // Set new intersected object
      if (intersects.length > 0) {
        let found = false;
        
        // Find the first object with userData.type
        for (let i = 0; i < intersects.length; i++) {
          const object = intersects[i].object;
          
          if (object.userData && object.userData.type) {
            this.intersectedObject = object;
            found = true;
            
            // Handle hover in
            eventBus.publish('object-hover', {
              type: 'in',
              object: this.intersectedObject
            });
            
            break;
          }
        }
        
        // Update cursor style
        document.body.style.cursor = found ? 'pointer' : 'auto';
      } else {
        // Reset cursor style
        document.body.style.cursor = 'auto';
      }
    }
  }
  
  /**
   * Clean up event listeners
   */
  dispose() {
    // Remove event listeners
    document.removeEventListener('keydown', this.onKeyDown);
    document.removeEventListener('keyup', this.onKeyUp);
    this.domElement.removeEventListener('click', this.onClick);
    document.removeEventListener('pointerlockchange', this.onLockChange);
    document.removeEventListener('mousemove', this.onMouseMove);
    document.removeEventListener('click', this.onObjectClick);
    
    // Dispose controls
    this.controls.dispose();
  }
}

export default Controls;

================
File: src/view/threeView/components/pipe.js
================
/**
 * Pipe component for representing relationships between classes
 * @module view/threeView/components/pipe
 */

import * as THREE from 'three';
import config from '../../../core/config.js';

class Pipe {
  /**
   * Create a new Pipe component
   * @param {Object} params - Parameters
   * @param {RelationshipEntity} params.relationshipEntity - Relationship entity to represent
   * @param {Sphere} params.sourceSphere - Source sphere
   * @param {Sphere} params.targetSphere - Target sphere
   * @param {THREE.Group} params.parent - Parent group to add pipe to
   */
  constructor({ relationshipEntity, sourceSphere, targetSphere, parent }) {
    this.relationshipEntity = relationshipEntity;
    this.sourceSphere = sourceSphere;
    this.targetSphere = targetSphere;
    this.parent = parent;
    
    // Get pipe radius from config
    this.radius = config.visualization.pipe.defaultRadius;
    
    // Create the pipe mesh
    this.createPipe();
    
    // Create label
    this.createLabel();
    
    // Add to parent
    this.parent.add(this.mesh);
  }
  
  /**
   * Create the pipe mesh
   */
  createPipe() {
    // Get positions of source and target spheres
    const sourcePos = this.sourceSphere.getWorldPosition();
    const targetPos = this.targetSphere.getWorldPosition();
    
    // Account for sphere radii - adjust start and end points
    const direction = new THREE.Vector3().subVectors(targetPos, sourcePos).normalize();
    const sourceRadius = this.sourceSphere.getRadius();
    const targetRadius = this.targetSphere.getRadius();
    
    // Adjust start and end points to be on the sphere surfaces
    const start = new THREE.Vector3().copy(sourcePos).addScaledVector(direction, sourceRadius + 0.1);
    const end = new THREE.Vector3().copy(targetPos).addScaledVector(direction, -targetRadius - 0.1);
    
    // Calculate length of the pipe
    const length = start.distanceTo(end);
    
    // Create geometry
    this.geometry = new THREE.CylinderGeometry(
      this.radius,
      this.radius,
      length,
      config.visualization.pipe.segments,
      1,
      false
    );
    
    // Rotate and position geometry
    this.geometry.translate(0, length / 2, 0);
    this.geometry.rotateX(Math.PI / 2);
    
    // Create material
    this.material = new THREE.MeshPhongMaterial({
      color: config.visualization.pipe.defaultColor,
      shininess: 30
    });
    
    // Create mesh
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    
    // Position and orient the pipe
    this.mesh.position.copy(start);
    this.mesh.lookAt(end);
    
    // Add metadata to mesh
    this.mesh.userData = {
      type: 'relationship',
      uri: this.relationshipEntity.uri.value,
      label: this.relationshipEntity.label,
      entity: this.relationshipEntity
    };
    
    // Create an arrow at the target end
    this.createArrow(end, direction);
  }
  
  /**
   * Create an arrow at the target end
   * @param {THREE.Vector3} position - Position for the arrow
   * @param {THREE.Vector3} direction - Direction the arrow points
   */
  createArrow(position, direction) {
    // Create cone geometry for arrow
    const arrowGeometry = new THREE.ConeGeometry(
      this.radius * 2,
      this.radius * 4,
      config.visualization.pipe.segments
    );
    
    // Rotate to point along pipe
    arrowGeometry.rotateX(-Math.PI / 2);
    
    // Create material
    const arrowMaterial = new THREE.MeshPhongMaterial({
      color: config.visualization.pipe.defaultColor,
      shininess: 30
    });
    
    // Create mesh
    this.arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
    
    // Position arrow at the end of the pipe
    this.arrow.position.copy(position);
    this.arrow.lookAt(position.clone().sub(direction));
    
    // Add arrow to parent
    this.parent.add(this.arrow);
  }
  
  /**
   * Create a text label for the pipe
   */
  createLabel() {
    // Create a canvas for the texture
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 64;
    
    // Draw background
    context.fillStyle = 'rgba(50, 50, 50, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw border
    context.strokeStyle = 'white';
    context.lineWidth = 2;
    context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
    
    // Draw text
    context.font = '18px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(this.relationshipEntity.label, canvas.width / 2, canvas.height / 2);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Create sprite material
    const material = new THREE.SpriteMaterial({ map: texture });
    
    // Create sprite
    this.label = new THREE.Sprite(material);
    this.label.scale.set(5, 1.25, 1);
    
    // Position at middle of pipe
    const sourcePos = this.sourceSphere.getWorldPosition();
    const targetPos = this.targetSphere.getWorldPosition();
    const midpoint = new THREE.Vector3().addVectors(sourcePos, targetPos).multiplyScalar(0.5);
    
    // Elevate slightly
    midpoint.y += 1;
    
    this.label.position.copy(midpoint);
    
    // Add label to parent
    this.parent.add(this.label);
  }
  
  /**
   * Update the pipe based on sphere positions
   */
  update() {
    // Re-create pipe to update position and orientation
    this.dispose(false);
    this.createPipe();
    this.createLabel();
    
    // Update appearance based on selection state
    if (this.relationshipEntity.isSelected) {
      this.material.color.setHex(config.visualization.pipe.selectedColor);
      if (this.arrow) {
        this.arrow.material.color.setHex(config.visualization.pipe.selectedColor);
      }
    } else {
      this.material.color.setHex(config.visualization.pipe.defaultColor);
      if (this.arrow) {
        this.arrow.material.color.setHex(config.visualization.pipe.defaultColor);
      }
    }
    
    // Update visibility
    this.mesh.visible = this.relationshipEntity.isVisible;
    if (this.arrow) {
      this.arrow.visible = this.relationshipEntity.isVisible;
    }
    if (this.label) {
      this.label.visible = this.relationshipEntity.isVisible;
    }
  }
  
  /**
   * Clean up resources
   * @param {boolean} [removeFromParent=true] - Whether to remove from parent
   */
  dispose(removeFromParent = true) {
    // Remove from parent
    if (removeFromParent) {
      if (this.parent && this.mesh && this.mesh.parent === this.parent) {
        this.parent.remove(this.mesh);
      }
      
      if (this.parent && this.arrow && this.arrow.parent === this.parent) {
        this.parent.remove(this.arrow);
      }
      
      if (this.parent && this.label && this.label.parent === this.parent) {
        this.parent.remove(this.label);
      }
    }
    
    // Dispose of geometries and materials
    if (this.geometry) this.geometry.dispose();
    if (this.material) this.material.dispose();
    
    if (this.arrow) {
      if (this.arrow.geometry) this.arrow.geometry.dispose();
      if (this.arrow.material) this.arrow.material.dispose();
    }
    
    if (this.label) {
      if (this.label.material.map) this.label.material.map.dispose();
      if (this.label.material) this.label.material.dispose();
    }
  }
}

export default Pipe;

================
File: src/view/threeView/components/port.js
================
/**
 * Port component for representing interfaces on classes
 * @module view/threeView/components/port
 */

import * as THREE from 'three';
import config from '../../../core/config.js';

class Port {
  /**
   * Create a new Port component
   * @param {Object} params - Parameters
   * @param {InterfaceEntity} params.interfaceEntity - Interface entity to represent
   * @param {Sphere} params.parentSphere - Parent sphere this port belongs to
   */
  constructor({ interfaceEntity, parentSphere }) {
    this.interfaceEntity = interfaceEntity;
    this.parentSphere = parentSphere;
    
    // Get port radius from config
    this.radius = config.visualization.port.defaultRadius;
    
    // Create geometry
    this.geometry = new THREE.SphereGeometry(
      this.radius,
      config.visualization.port.segments,
      config.visualization.port.segments
    );
    
    // Create material
    this.material = new THREE.MeshPhongMaterial({
      color: config.visualization.port.defaultColor,
      shininess: 50
    });
    
    // Create mesh
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    
    // Position port on parent sphere
    this.updatePosition();
    
    // Add metadata to mesh
    this.mesh.userData = {
      type: 'interface',
      uri: this.interfaceEntity.uri.value,
      label: this.interfaceEntity.label,
      entity: this.interfaceEntity
    };
    
    // Create label
    this.createLabel();
    
    // Add to parent sphere
    this.parentSphere.mesh.add(this.mesh);
    
    // Register with parent sphere
    this.parentSphere.addPort(this);
  }
  
  /**
   * Create a text label for the port
   */
  createLabel() {
    // Create a canvas for the texture
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 128;
    canvas.height = 64;
    
    // Draw background
    context.fillStyle = 'rgba(50, 50, 50, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw border
    context.strokeStyle = 'white';
    context.lineWidth = 2;
    context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
    
    // Draw text
    context.font = '12px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(this.interfaceEntity.label, canvas.width / 2, canvas.height / 2);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Create sprite material
    const material = new THREE.SpriteMaterial({ map: texture });
    
    // Create sprite
    this.label = new THREE.Sprite(material);
    this.label.scale.set(2, 1, 1);
    
    // Position relative to port
    this.label.position.set(0, 1, 0);
    
    // Add label to mesh
    this.mesh.add(this.label);
  }
  
  /**
   * Update the position of the port on the parent sphere
   */
  updatePosition() {
    // Calculate position in spherical coordinates
    const sphereRadius = this.parentSphere.getRadius();
    const { phi, theta } = this.interfaceEntity.position;
    
    // Convert to Cartesian coordinates
    const x = sphereRadius * Math.sin(theta) * Math.cos(phi);
    const y = sphereRadius * Math.sin(theta) * Math.sin(phi);
    const z = sphereRadius * Math.cos(theta);
    
    // Set position
    this.mesh.position.set(x, y, z);
  }
  
  /**
   * Update the appearance of the port
   */
  update() {
    // Update position on sphere
    this.updatePosition();
    
    // Update appearance based on selection state
    if (this.interfaceEntity.isSelected) {
      this.material.color.setHex(config.visualization.port.selectedColor);
    } else {
      this.material.color.setHex(config.visualization.port.defaultColor);
    }
    
    // Update visibility
    this.mesh.visible = this.interfaceEntity.isVisible;
    if (this.label) {
      this.label.visible = this.interfaceEntity.isVisible;
    }
  }
  
  /**
   * Get world position of the port
   * @returns {THREE.Vector3} World position
   */
  getWorldPosition() {
    const position = new THREE.Vector3();
    this.mesh.getWorldPosition(position);
    return position;
  }
  
  /**
   * Show detailed information about the interface
   * @param {HTMLElement} infoPanel - DOM element to display information in
   */
  showDetails(infoPanel) {
    // Clear existing content
    infoPanel.innerHTML = '';
    
    // Create header
    const header = document.createElement('h3');
    header.textContent = this.interfaceEntity.label;
    infoPanel.appendChild(header);
    
    // Create interface type
    const type = document.createElement('p');
    type.textContent = `Interface URI: ${this.interfaceEntity.uri.value}`;
    infoPanel.appendChild(type);
    
    // Create methods section
    const methodsHeader = document.createElement('h4');
    methodsHeader.textContent = 'Methods:';
    infoPanel.appendChild(methodsHeader);
    
    if (this.interfaceEntity.methods.length === 0) {
      const noMethods = document.createElement('p');
      noMethods.textContent = 'No methods defined.';
      infoPanel.appendChild(noMethods);
    } else {
      const methodsList = document.createElement('ul');
      
      this.interfaceEntity.methods.forEach(method => {
        const methodItem = document.createElement('li');
        
        // Format method signature
        let signature = `${method.returnType} ${method.name}(`;
        
        if (method.parameters.length > 0) {
          signature += method.parameters.map(param => `${param.type} ${param.name}`).join(', ');
        }
        
        signature += ')';
        
        methodItem.textContent = signature;
        methodsList.appendChild(methodItem);
      });
      
      infoPanel.appendChild(methodsList);
    }
  }
  
  /**
   * Clean up resources
   */
  dispose() {
    // Remove from parent
    if (this.mesh.parent) {
      this.mesh.parent.remove(this.mesh);
    }
    
    // Dispose of geometry and material
    if (this.geometry) this.geometry.dispose();
    if (this.material) this.material.dispose();
    
    // Clean up label
    if (this.label) {
      if (this.label.material.map) this.label.material.map.dispose();
      if (this.label.material) this.label.material.dispose();
    }
  }
}

export default Port;

================
File: src/view/threeView/components/sphere.js
================
/**
 * Sphere component for representing classes
 * @module view/threeView/components/sphere
 */

import * as THREE from 'three';
import config from '../../../core/config.js';

class Sphere {
  /**
   * Create a new Sphere component
   * @param {Object} params - Parameters
   * @param {ClassEntity} params.classEntity - Class entity to represent
   * @param {THREE.Group} params.parent - Parent group to add sphere to
   */
  constructor({ classEntity, parent }) {
    this.classEntity = classEntity;
    this.parent = parent;
    this.ports = new Map(); // URI string -> Port
    
    // Create geometry
    const radius = classEntity.radius || config.visualization.sphere.defaultRadius;
    this.geometry = new THREE.SphereGeometry(
      radius,
      config.visualization.sphere.segments,
      config.visualization.sphere.segments
    );
    
    // Create material
    this.material = new THREE.MeshPhongMaterial({
      color: config.visualization.sphere.defaultColor,
      transparent: true,
      opacity: config.visualization.sphere.opacity,
      shininess: 30
    });
    
    // Create mesh
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.mesh.position.set(
      classEntity.position.x || 0,
      classEntity.position.y || 0,
      classEntity.position.z || 0
    );
    
    // Add metadata to mesh
    this.mesh.userData = {
      type: 'class',
      uri: classEntity.uri.value,
      label: classEntity.label,
      entity: classEntity
    };
    
    // Create label
    this.createLabel();
    
    // Add to parent
    this.parent.add(this.mesh);
  }
  
  /**
   * Create a text label for the sphere
   */
  createLabel() {
    // Create a canvas for the texture
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 128;
    
    // Draw background
    context.fillStyle = 'rgba(50, 50, 50, 0.7)';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw border
    context.strokeStyle = 'white';
    context.lineWidth = 2;
    context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
    
    // Draw text
    context.font = '24px Arial';
    context.fillStyle = 'white';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(this.classEntity.label, canvas.width / 2, canvas.height / 2);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    
    // Create sprite material
    const material = new THREE.SpriteMaterial({ map: texture });
    
    // Create sprite
    this.label = new THREE.Sprite(material);
    this.label.scale.set(5, 2.5, 1);
    
    // Position above sphere
    const yOffset = this.classEntity.radius + 2;
    this.label.position.set(0, yOffset, 0);
    
    // Add label to mesh
    this.mesh.add(this.label);
  }
  
  /**
   * Update the position and appearance of the sphere
   */
  update() {
    // Update position
    this.mesh.position.set(
      this.classEntity.position.x,
      this.classEntity.position.y,
      this.classEntity.position.z
    );
    
    // Update appearance based on selection state
    if (this.classEntity.isSelected) {
      this.material.color.setHex(config.visualization.sphere.selectedColor);
      this.material.opacity = 1.0;
    } else {
      this.material.color.setHex(config.visualization.sphere.defaultColor);
      this.material.opacity = config.visualization.sphere.opacity;
    }
  }
  
  /**
   * Add a port to this sphere
   * @param {Port} port - Port component to add
   */
  addPort(port) {
    const uriString = port.interfaceEntity.uri.value;
    this.ports.set(uriString, port);
  }
  
  /**
   * Get world position of the sphere
   * @returns {THREE.Vector3} World position
   */
  getWorldPosition() {
    const position = new THREE.Vector3();
    this.mesh.getWorldPosition(position);
    return position;
  }
  
  /**
   * Get the radius of the sphere
   * @returns {number} Sphere radius
   */
  getRadius() {
    return this.classEntity.radius;
  }
  
  /**
   * Show the sphere
   */
  show() {
    this.mesh.visible = true;
  }
  
  /**
   * Hide the sphere
   */
  hide() {
    this.mesh.visible = false;
  }
  
  /**
   * Clean up resources
   */
  dispose() {
    // Remove from parent
    if (this.parent && this.mesh.parent === this.parent) {
      this.parent.remove(this.mesh);
    }
    
    // Dispose of geometry and material
    if (this.geometry) this.geometry.dispose();
    if (this.material) this.material.dispose();
    
    // Clean up sprite
    if (this.label) {
      if (this.label.material.map) this.label.material.map.dispose();
      if (this.label.material) this.label.material.dispose();
    }
  }
}

export default Sphere;

================
File: src/view/threeView/threeView.js
================
/**
 * ThreeView renders the 3D visualization of the conceptual model
 * @module view/threeView/threeView
 */

import * as THREE from 'three';
import log from 'loglevel';
import eventBus from '../../core/eventBus.js';
import config from '../../core/config.js';
import Controls from './components/controls.js';
import Sphere from './components/sphere.js';
import Pipe from './components/pipe.js';
import Port from './components/port.js';

// Added debugging
console.log('ThreeView module loading');

class ThreeView {
  /**
   * Create a ThreeView
   * @param {ConceptModel} conceptModel - Conceptual model
   * @param {HTMLElement} container - DOM element to render into
   */
  constructor(conceptModel, container) {
    console.log('ThreeView constructor', {
      conceptModel: conceptModel ? 'provided' : 'missing',
      container: container ? 'provided' : 'missing'
    });

    this.conceptModel = conceptModel;
    this.container = container;
    this.log = log.getLogger('ThreeView');

    // Component maps
    this.spheres = new Map(); // URI string -> Sphere
    this.pipes = new Map(); // URI string -> Pipe
    this.ports = new Map(); // URI string -> Port

    // Initialize THREE.js
    this.initThree();

    // Add event listeners
    window.addEventListener('resize', this.onResize.bind(this));

    // Subscribe to model changes
    eventBus.subscribe('concept-model-changed', (data) => {
      console.log('concept-model-changed event received in ThreeView', data);
      this.updateFromModel();
    });

    // Subscribe to object selection
    eventBus.subscribe('object-selected', this.onObjectSelected.bind(this));
    eventBus.subscribe('object-deselected', this.onObjectDeselected.bind(this));

    // Track navigation hierarchy
    this.navigationStack = [];
    this.currentClassUri = null;

    // Animation loop
    this.animate = this.animate.bind(this);
    this.clock = new THREE.Clock();
    this.animate();

    console.log('ThreeView construction complete');
  }

  /**
   * Initialize THREE.js renderer, scene, and camera
   */
  initThree() {
    console.log('Initializing Three.js');

    // Create renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.container.appendChild(this.renderer.domElement);
    console.log('Renderer created and added to container');

    // Create scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x111133);
    console.log('Scene created with background color');

    // Add debug grid and axes to help with orientation
    const gridHelper = new THREE.GridHelper(20, 20);
    this.scene.add(gridHelper);
    console.log('Grid helper added');

    const axesHelper = new THREE.AxesHelper(5);
    this.scene.add(axesHelper);
    console.log('Axes helper added');

    // Add a simple sphere to verify rendering is working
    const debugSphere = new THREE.Mesh(
      new THREE.SphereGeometry(2, 32, 32),
      new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    debugSphere.position.set(0, 0, 0);
    this.scene.add(debugSphere);
    console.log('Debug sphere added at origin (0,0,0)');

    // Create camera
    this.camera = new THREE.PerspectiveCamera(
      config.visualization.camera.fov,
      this.container.clientWidth / this.container.clientHeight,
      config.visualization.camera.near,
      config.visualization.camera.far
    );
    this.camera.position.set(
      config.visualization.camera.position.x,
      config.visualization.camera.position.y,
      config.visualization.camera.position.z
    );
    console.log('Camera created at position', this.camera.position);

    // Create controls
    console.log('Creating Controls');
    this.controls = new Controls(this.camera, this.renderer.domElement);
    console.log('Controls created');

    // Add lights
    this.addLights();

    // Create object groups
    this.spheresGroup = new THREE.Group();
    this.pipesGroup = new THREE.Group();
    this.scene.add(this.spheresGroup);
    this.scene.add(this.pipesGroup);
    console.log('Sphere and pipe groups added to scene');

    this.log.debug('THREE.js initialized');
    console.log('THREE.js initialization complete');
  }

  /**
   * Add lights to the scene
   */
  addLights() {
    console.log('Adding lights to scene');

    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0x404040);
    this.scene.add(ambientLight);

    // Add directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1);
    this.scene.add(directionalLight);

    // Add point lights
    const pointLight1 = new THREE.PointLight(0xffffff, 0.5);
    pointLight1.position.set(50, 50, 50);
    this.scene.add(pointLight1);

    const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
    pointLight2.position.set(-50, -50, -50);
    this.scene.add(pointLight2);

    console.log('Lights added to scene');
  }

  /**
   * Update the view from the conceptual model
   */
  updateFromModel() {
    this.log.info('Updating ThreeView from conceptual model');
    console.log('Updating ThreeView from conceptual model');

    // Clear current visualization
    this.clearVisualization();

    // If we're showing a specific class's internals
    if (this.currentClassUri) {
      console.log('Rendering internals for class:', this.currentClassUri);
      this.renderClassInternals(this.currentClassUri);
    } else {
      // Render all top-level classes
      console.log('Rendering all top-level classes');
      this.renderClasses();

      // Render relationships between classes
      console.log('Rendering relationships between classes');
      this.renderRelationships();

      // Render interfaces on classes
      console.log('Rendering interfaces on classes');
      this.renderInterfaces();
    }

    console.log('ThreeView update complete');
  }

  /**
   * Clear the current visualization
   */
  clearVisualization() {
    console.log('Clearing visualization');

    // Dispose and clear spheres
    for (const sphere of this.spheres.values()) {
      sphere.dispose();
    }
    this.spheres.clear();

    // Dispose and clear pipes
    for (const pipe of this.pipes.values()) {
      pipe.dispose();
    }
    this.pipes.clear();

    // Dispose and clear ports
    for (const port of this.ports.values()) {
      port.dispose();
    }
    this.ports.clear();

    console.log('Visualization cleared');
  }

  /**
   * Render all classes in the conceptual model
   */
  renderClasses() {
    console.log('Rendering classes from conceptual model');
    console.log('Classes in model:', this.conceptModel.classes.size);

    for (const classEntity of this.conceptModel.classes.values()) {
      console.log('Rendering class:', classEntity.label);
      this.renderClass(classEntity);
    }

    console.log('Classes rendering complete');
  }

  /**
   * Render a single class entity
   * @param {ClassEntity} classEntity - Class entity to render
   * @returns {Sphere} The created sphere component
   */
  renderClass(classEntity) {
    const uriString = classEntity.uri.value;
    console.log('Rendering class:', classEntity.label, uriString);

    // Skip if we already have this class
    if (this.spheres.has(uriString)) {
      console.log('Class already rendered, skipping:', uriString);
      return this.spheres.get(uriString);
    }

    // Create sphere for the class
    try {
      console.log('Creating sphere for class:', classEntity.label);
      const sphere = new Sphere({
        classEntity,
        parent: this.spheresGroup
      });

      // Store the sphere
      this.spheres.set(uriString, sphere);

      this.log.debug(`Rendered class: ${classEntity.label} (${uriString})`);
      console.log(`Rendered class: ${classEntity.label} (${uriString})`);

      return sphere;
    } catch (error) {
      console.error('Error creating sphere for class:', classEntity.label, error);
      return null;
    }
  }

  /**
   * Render relationships between classes
   */
  renderRelationships() {
    console.log('Rendering relationships');
    console.log('Relationships in model:', this.conceptModel.relationships.size);

    for (const relationshipEntity of this.conceptModel.relationships.values()) {
      console.log('Rendering relationship:', relationshipEntity.label);
      this.renderRelationship(relationshipEntity);
    }

    console.log('Relationships rendering complete');
  }

  /**
   * Render a single relationship entity
   * @param {RelationshipEntity} relationshipEntity - Relationship entity to render
   * @returns {Pipe} The created pipe component
   */
  renderRelationship(relationshipEntity) {
    const uriString = relationshipEntity.uri.value;
    console.log('Rendering relationship:', relationshipEntity.label, uriString);

    // Skip if we already have this relationship
    if (this.pipes.has(uriString)) {
      console.log('Relationship already rendered, skipping:', uriString);
      return this.pipes.get(uriString);
    }

    const sourceUriString = relationshipEntity.sourceClassUri.value;
    const targetUriString = relationshipEntity.targetClassUri.value;

    console.log('Looking for spheres:', {
      source: sourceUriString,
      sourceSphere: this.spheres.has(sourceUriString),
      target: targetUriString,
      targetSphere: this.spheres.has(targetUriString)
    });

    // Try to find spheres with various URI patterns
    // Sometimes the URI can be slightly different (with or without trailing slash)
    const sourceSphere = this.findSphereByUri(sourceUriString);
    const targetSphere = this.findSphereByUri(targetUriString);

    // Skip if we don't have the source or target class
    if (!sourceSphere || !targetSphere) {
      this.log.warn(`Cannot render relationship ${uriString}: missing ` +
        (sourceSphere ? '' : 'source ') +
        (targetSphere ? '' : 'target'));
      console.warn(`Cannot render relationship ${uriString}: missing ` +
        (sourceSphere ? '' : 'source ') +
        (targetSphere ? '' : 'target'));
      return null;
    }

    // Create pipe for the relationship
    try {
      console.log('Creating pipe for relationship:', relationshipEntity.label,
        'from', sourceSphere.classEntity.label, 'to', targetSphere.classEntity.label);

      const pipe = new Pipe({
        relationshipEntity,
        sourceSphere,
        targetSphere,
        parent: this.pipesGroup
      });

      // Store the pipe
      this.pipes.set(uriString, pipe);

      this.log.debug(`Rendered relationship: ${relationshipEntity.label} (${uriString})`);
      console.log(`Rendered relationship: ${relationshipEntity.label} (${uriString})`);

      return pipe;
    } catch (error) {
      console.error('Error creating pipe for relationship:', relationshipEntity.label, error);
      return null;
    }
  }

  /**
   * Find a sphere by URI, trying different variations of the URI
   * @param {string} uri - URI to search for
   * @returns {Sphere|null} The found sphere or null
   */
  findSphereByUri(uri) {
    // Try exact match first
    if (this.spheres.has(uri)) {
      return this.spheres.get(uri);
    }

    // Try with/without trailing slash
    const altUri = uri.endsWith('/') ? uri.slice(0, -1) : uri + '/';
    if (this.spheres.has(altUri)) {
      return this.spheres.get(altUri);
    }

    // Try simpler version (just the local name)
    const localName = uri.split('/').pop().split('#').pop();

    // Look for a sphere that has this local name in its URI
    for (const [sphereUri, sphere] of this.spheres.entries()) {
      if (sphereUri.includes(localName)) {
        console.log(`Found sphere with similar URI: ${sphereUri} for ${uri}`);
        return sphere;
      }
    }

    // Print available sphere URIs for debugging
    if (this.spheres.size > 0) {
      console.log('Available sphere URIs:', Array.from(this.spheres.keys()));
    }

    return null;
  }

  /**
   * Render interfaces on classes
   */
  renderInterfaces() {
    console.log('Rendering interfaces');
    console.log('Interfaces in model:', this.conceptModel.interfaces.size);

    for (const interfaceEntity of this.conceptModel.interfaces.values()) {
      console.log('Rendering interface:', interfaceEntity.label);
      this.renderInterface(interfaceEntity);
    }

    console.log('Interfaces rendering complete');
  }

  /**
   * Render a single interface entity
   * @param {InterfaceEntity} interfaceEntity - Interface entity to render
   * @returns {Port} The created port component
   */
  renderInterface(interfaceEntity) {
    const uriString = interfaceEntity.uri.value;
    console.log('Rendering interface:', interfaceEntity.label, uriString);

    // Skip if we already have this interface
    if (this.ports.has(uriString)) {
      console.log('Interface already rendered, skipping:', uriString);
      return this.ports.get(uriString);
    }

    const classUriString = interfaceEntity.classUri.value;

    // Skip if we don't have the class
    if (!this.spheres.has(classUriString)) {
      this.log.warn(`Cannot render interface ${uriString}: missing class ${classUriString}`);
      console.warn(`Cannot render interface ${uriString}: missing class ${classUriString}`);
      return null;
    }

    // Get parent sphere
    const parentSphere = this.spheres.get(classUriString);

    // Create port for the interface
    try {
      console.log('Creating port for interface:', interfaceEntity.label);
      const port = new Port({
        interfaceEntity,
        parentSphere
      });

      // Store the port
      this.ports.set(uriString, port);

      this.log.debug(`Rendered interface: ${interfaceEntity.label} (${uriString})`);
      console.log(`Rendered interface: ${interfaceEntity.label} (${uriString})`);

      return port;
    } catch (error) {
      console.error('Error creating port for interface:', interfaceEntity.label, error);
      return null;
    }
  }

  /**
   * Render the internals of a class
   * @param {string} classUriString - URI of the class to render internals for
   */
  renderClassInternals(classUriString) {
    const classEntity = this.conceptModel.getClass(classUriString);

    if (!classEntity) {
      this.log.error(`Cannot render internals for unknown class ${classUriString}`);
      console.error(`Cannot render internals for unknown class ${classUriString}`);
      return;
    }

    this.log.info(`Rendering internals for class ${classEntity.label} (${classUriString})`);
    console.log(`Rendering internals for class ${classEntity.label} (${classUriString})`);

    // Render subclasses
    for (const subclassUri of classEntity.subclasses) {
      const subclassEntity = this.conceptModel.getClass(subclassUri.value);

      if (subclassEntity) {
        this.renderClass(subclassEntity);
      }
    }

    // Render relationships between subclasses
    for (const relationshipEntity of this.conceptModel.relationships.values()) {
      const sourceUriString = relationshipEntity.sourceClassUri.value;
      const targetUriString = relationshipEntity.targetClassUri.value;

      // Only render relationships between subclasses
      if (this.spheres.has(sourceUriString) && this.spheres.has(targetUriString)) {
        this.renderRelationship(relationshipEntity);
      }
    }

    // Render interfaces on subclasses
    for (const interfaceEntity of this.conceptModel.interfaces.values()) {
      const interfaceClassUriString = interfaceEntity.classUri.value;

      // Only render interfaces on subclasses
      if (this.spheres.has(interfaceClassUriString)) {
        this.renderInterface(interfaceEntity);
      }
    }

    console.log('Class internals rendering complete');
  }

  /**
   * Navigate into a class sphere to view its internals
   * @param {string} classUriString - URI of the class to enter
   */
  enterClass(classUriString) {
    const classEntity = this.conceptModel.getClass(classUriString);

    if (!classEntity) {
      this.log.error(`Cannot enter unknown class ${classUriString}`);
      console.error(`Cannot enter unknown class ${classUriString}`);
      return;
    }

    // Push current state to navigation stack
    this.navigationStack.push({
      classUri: this.currentClassUri,
      cameraPosition: this.camera.position.clone(),
      cameraRotation: this.camera.rotation.clone()
    });

    // Set current class
    this.currentClassUri = classUriString;

    // Reset camera position
    this.camera.position.set(0, 0, 15);
    this.camera.rotation.set(0, 0, 0);

    // Update view
    this.updateFromModel();

    this.log.info(`Entered class ${classEntity.label} (${classUriString})`);
    console.log(`Entered class ${classEntity.label} (${classUriString})`);
    eventBus.publish('class-entered', { classEntity });
  }

  /**
   * Navigate out of the current class
   */
  exitClass() {
    if (this.navigationStack.length === 0) {
      this.log.warn('Cannot exit class: navigation stack is empty');
      console.warn('Cannot exit class: navigation stack is empty');
      return;
    }

    // Pop state from navigation stack
    const state = this.navigationStack.pop();

    // Get the class we're exiting from
    const exitingClassEntity = this.conceptModel.getClass(this.currentClassUri);

    // Restore state
    this.currentClassUri = state.classUri;
    this.camera.position.copy(state.cameraPosition);
    this.camera.rotation.copy(state.cameraRotation);

    // Update view
    this.updateFromModel();

    this.log.info(`Exited class ${exitingClassEntity?.label || 'unknown'}`);
    console.log(`Exited class ${exitingClassEntity?.label || 'unknown'}`);
    eventBus.publish('class-exited', { classEntity: exitingClassEntity });
  }

  /**
   * Handle object selection
   * @param {Object} data - Selection data
   * @param {string} data.type - Object type (class, relationship, interface)
   * @param {string} data.uri - Object URI
   * @param {Object} data.entity - Object entity
   */
  onObjectSelected(data) {
    const { type, uri } = data;
    console.log('onObjectSelected:', type, uri);

    if (type === 'class') {
      const classEntity = this.conceptModel.getClass(uri);

      if (classEntity) {
        classEntity.isSelected = true;

        // Update sphere appearance
        const sphere = this.spheres.get(uri);
        if (sphere) {
          sphere.update();
        }
      }
    } else if (type === 'relationship') {
      const relationshipEntity = this.conceptModel.getRelationship(uri);

      if (relationshipEntity) {
        relationshipEntity.isSelected = true;

        // Update pipe appearance
        const pipe = this.pipes.get(uri);
        if (pipe) {
          pipe.update();
        }
      }
    } else if (type === 'interface') {
      const interfaceEntity = this.conceptModel.getInterface(uri);

      if (interfaceEntity) {
        interfaceEntity.isSelected = true;

        // Update port appearance
        const port = this.ports.get(uri);
        if (port) {
          port.update();
        }
      }
    }
  }

  /**
   * Handle object deselection
   * @param {Object} data - Deselection data
   * @param {string} data.type - Object type (class, relationship, interface)
   * @param {string} data.uri - Object URI
   */
  onObjectDeselected(data) {
    const { type, uri } = data;
    console.log('onObjectDeselected:', type, uri);

    if (type === 'class') {
      const classEntity = this.conceptModel.getClass(uri);

      if (classEntity) {
        classEntity.isSelected = false;

        // Update sphere appearance
        const sphere = this.spheres.get(uri);
        if (sphere) {
          sphere.update();
        }
      }
    } else if (type === 'relationship') {
      const relationshipEntity = this.conceptModel.getRelationship(uri);

      if (relationshipEntity) {
        relationshipEntity.isSelected = false;

        // Update pipe appearance
        const pipe = this.pipes.get(uri);
        if (pipe) {
          pipe.update();
        }
      }
    } else if (type === 'interface') {
      const interfaceEntity = this.conceptModel.getInterface(uri);

      if (interfaceEntity) {
        interfaceEntity.isSelected = false;

        // Update port appearance
        const port = this.ports.get(uri);
        if (port) {
          port.update();
        }
      }
    }
  }

  /**
   * Handle window resize
   */
  onResize() {
    // Update camera aspect ratio
    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
    this.camera.updateProjectionMatrix();

    // Update renderer size
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
  }

  /**
   * Animation loop
   */
  animate() {
    requestAnimationFrame(this.animate);

    // Get delta time
    const deltaTime = this.clock.getDelta();

    // Update controls
    this.controls.update(deltaTime, this.scene);

    // Render scene
    this.renderer.render(this.scene, this.camera);
  }

  /**
   * Clean up resources
   */
  dispose() {
    // Stop animation loop
    cancelAnimationFrame(this.animate);

    // Remove event listeners
    window.removeEventListener('resize', this.onResize);

    // Dispose of controls
    this.controls.dispose();

    // Dispose of components
    this.clearVisualization();

    // Dispose of THREE.js resources
    this.renderer.dispose();

    // Remove renderer from DOM
    if (this.renderer.domElement.parentNode) {
      this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
    }
  }
}

export default ThreeView;

================
File: src/app.js
================
/**
 * Main UVE application entry point
 * @module app
 */

import log from 'loglevel';
import eventBus from './core/eventBus.js';
import config from './core/config.js';
import RDFModel from './model/rdfModel.js';
import ConceptModel from './model/conceptModel.js';
import ThreeView from './view/threeView/threeView.js';
import RDFFileView from './view/rdfView/rdfFileView.js';
import { createFOAFExample, loadFOAFExample } from './examples/foafExample.js';
import storageManager from './util/storageManager.js';

// Add debugging
console.log('src/app.js loading');
console.log('Config:', config);

/**
 * Main application class
 */
class App {
  /**
   * Create UVE application
   */
  constructor() {
    console.log('App constructor running');

    // Configure logging
    log.setLevel(config.system.logLevel);
    this.log = log.getLogger('App');

    // Initialize model
    this.initModel();

    // Initialize views
    this.initViews();

    // Load example data
    this.loadExampleData();

    // Subscribe to events
    this.setupEvents();

    this.log.info('UVE application initialized');
    console.log('UVE application initialized from App constructor');

    // Log application state for debugging
    console.log('App state:', {
      model: this.rdfModel ? 'loaded' : 'missing',
      conceptModel: this.conceptModel ? 'loaded' : 'missing',
      threeView: this.threeView ? 'loaded' : 'missing',
      rdfView: this.rdfView ? 'loaded' : 'missing'
    });
  }

  /**
   * Initialize the data model
   */
  initModel() {
    this.log.debug('Initializing model');
    console.log('Initializing model');

    // Create RDF model
    this.rdfModel = new RDFModel();

    // Create concept model
    this.conceptModel = new ConceptModel(this.rdfModel);

    console.log('Model initialized successfully');
  }

  /**
   * Initialize the views
   */
  initViews() {
    this.log.debug('Initializing views');
    console.log('Initializing views');

    // Find view containers
    const threeViewContainer = document.getElementById('three-view-container');
    const rdfViewContainer = document.getElementById('rdf-view-container');

    if (!threeViewContainer || !rdfViewContainer) {
      this.log.error('View containers not found in DOM');
      console.error('View containers not found:',
        threeViewContainer ? 'three-view-container found' : 'three-view-container MISSING',
        rdfViewContainer ? 'rdf-view-container found' : 'rdf-view-container MISSING'
      );

      // Log available DOM elements for debugging
      console.log('DOM elements:',
        Array.from(document.querySelectorAll('body > *'))
          .map(el => `${el.tagName}${el.id ? '#' + el.id : ''}`)
      );

      throw new Error('View containers not found');
    }

    console.log('View containers found:', {
      threeViewContainer,
      rdfViewContainer
    });

    // Create Three.js view
    console.log('Creating ThreeView');
    this.threeView = new ThreeView(this.conceptModel, threeViewContainer);
    console.log('ThreeView created');

    // Create RDF file view
    console.log('Creating RDFFileView');
    this.rdfView = new RDFFileView(this.rdfModel, rdfViewContainer);
    console.log('RDFFileView created');

    console.log('Views initialized successfully');
  }

  /**
   * Load example data
   */
  async loadExampleData() {
    this.log.info('Loading example FOAF data');
    console.log('Loading example FOAF data');

    try {
      // Try to load FOAF example from storage first
      let dataset;
      try {
        console.log('Attempting to load FOAF example from storage');
        dataset = await loadFOAFExample();
        this.log.info('Loaded FOAF example from storage');
        console.log('Loaded FOAF example from storage');
      } catch (error) {
        this.log.warn('Failed to load from storage, creating new FOAF example:', error);
        console.warn('Failed to load from storage, creating new FOAF example:', error);
        console.log('Creating new FOAF example');
        dataset = createFOAFExample();
      }

      console.log('FOAF dataset loaded with', dataset ? dataset.size : 0, 'triples');

      if (!dataset) {
        console.error('Failed to create FOAF dataset');
        return;
      }

      // Add to RDF model
      this.rdfModel.dataset.deleteMatches();
      this.rdfModel.dataset.addAll(dataset);

      // Notify of change
      console.log('Publishing rdf-model-changed event');
      eventBus.publish('rdf-model-changed', { source: 'example' });

      this.log.info(`Loaded ${dataset.size} triples from FOAF example`);
      console.log(`Loaded ${dataset.size} triples from FOAF example`);
    } catch (error) {
      this.log.error('Failed to load example data:', error);
      console.error('Failed to load example data:', error);
    }
  }

  /**
   * Set up event handlers
   */
  setupEvents() {
    console.log('Setting up events');

    // Handle class enter/exit
    eventBus.subscribe('object-selected', data => {
      console.log('object-selected event received:', data);
      if (data.type === 'class' && data.entity.subclasses.length > 0) {
        // If the class has subclasses, show an "Enter Class" button
        this.showEnterClassButton(data.uri, data.entity.label);
      } else {
        this.hideEnterClassButton();
      }
    });

    eventBus.subscribe('object-deselected', () => {
      console.log('object-deselected event received');
      this.hideEnterClassButton();
    });

    // Create and add enter class button to DOM (hidden initially)
    this.enterClassButton = document.createElement('button');
    this.enterClassButton.id = 'enter-class-button';
    this.enterClassButton.className = 'enter-class-button hidden';
    this.enterClassButton.textContent = 'Enter Class';
    document.body.appendChild(this.enterClassButton);

    // Create and add exit class button to DOM (hidden initially)
    this.exitClassButton = document.createElement('button');
    this.exitClassButton.id = 'exit-class-button';
    this.exitClassButton.className = 'exit-class-button hidden';
    this.exitClassButton.textContent = 'Exit Class';
    this.exitClassButton.addEventListener('click', () => {
      this.threeView.exitClass();
      this.exitClassButton.classList.add('hidden');
    });
    document.body.appendChild(this.exitClassButton);

    // Debug events
    eventBus.subscribe('rdf-model-changed', data => {
      console.log('RDF model changed:', data);
    });

    eventBus.subscribe('concept-model-changed', data => {
      console.log('Concept model changed:', data);
    });

    console.log('Events set up successfully');
  }

  /**
   * Show the enter class button for a specific class
   * @param {string} classUri - URI of the class
   * @param {string} label - Label of the class
   */
  showEnterClassButton(classUri, label) {
    this.enterClassButton.textContent = `Enter ${label}`;
    this.enterClassButton.classList.remove('hidden');

    // Remove any existing click event
    const newButton = this.enterClassButton.cloneNode(true);
    this.enterClassButton.parentNode.replaceChild(newButton, this.enterClassButton);
    this.enterClassButton = newButton;

    // Add click event for this specific class
    this.enterClassButton.addEventListener('click', () => {
      this.threeView.enterClass(classUri);
      this.enterClassButton.classList.add('hidden');
      this.exitClassButton.classList.remove('hidden');
    });
  }

  /**
   * Hide the enter class button
   */
  hideEnterClassButton() {
    this.enterClassButton.classList.add('hidden');
  }
}

// Start the application when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, initializing UVE application');
  window.app = new App();
  console.log('App instance created and available at window.app');
});

export default App;

================
File: src/index.js
================
/**
 * UVE application entry point
 */

// Initialize window.fs early
import './util/initFs.js';

// Import main application
import './app.js';

console.log('UVE application bootstrapped from src/index.js');

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: jsdoc.config.json
================
{
  "source": {
    "include": ["src", "README.md"],
    "exclude": ["node_modules"]
  },
  "opts": {
    "destination": "./docs/generated",
    "recurse": true,
    "template": "node_modules/docdash"
  },
  "plugins": ["plugins/markdown"],
  "templates": {
    "cleverLinks": true,
    "monospaceLinks": false
  },
  "docdash": {
    "static": true,
    "sort": true
  }
}

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "uve",
  "version": "0.1.0",
  "description": "Universal Virtual Environment - 3D visualization of conceptual space using Three.js and RDF",
  "main": "src/app.js",
  "type": "module",
  "scripts": {
    "rp": "repomix -c repomix.config.json .",
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "jasmine"
  },
  "keywords": [
    "rdf",
    "threejs",
    "visualization",
    "semantic-web",
    "3d"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@rdfjs/formats": "^4.0.1",
    "@rdfjs/formats-common": "^3.1.0",
    "@rdfjs/namespace": "^2.0.1",
    "grapoi": "^1.1.3",
    "loglevel": "^1.8.1",
    "rdf-ext": "^2.5.0",
    "rdf-utils-fs": "^2.3.0",
    "three": "^0.158.0"
  },
  "devDependencies": {
    "chai": "^4.3.7",
    "jasmine": "^5.1.0",
    "vite": "^4.5.0"
  }
}

================
File: README.md
================
# UVE - Universal Virtual Environment

A 3D visualization of conceptual space using Three.js and RDF/OWL models.

## Overview

UVE renders conceptual space in 3D, where:
- Classes are represented as spheres
- Relationships between classes are visualized as labeled pipes
- Interfaces appear as ports on sphere surfaces
- Navigation uses first-person camera with mouse/arrow key controls
- Hierarchical visualization with nested spaces (entering a class sphere reveals its subclasses)

The data model is represented using RDF/OWL models and accessed via RDF-Ext and Grapoi libraries.

## Features

- 3D visualization of class hierarchies
- Interactive navigation through conceptual space
- RDF data editing with live visualization updates
- Support for various RDF formats (Turtle, N-Triples, JSON-LD, etc.)
- FOAF vocabulary example with 5 friends

## Architecture

UVE follows a Model-View architecture with pub-sub messaging:
- **Core**: EventBus for pub-sub messaging and configuration
- **Model**: RDF dataset management and conceptual model transformation
- **Views**: Three.js 3D visualization and RDF file editing
- **Utilities**: Helper functions for various tasks

## Getting Started

### Prerequisites

- Node.js (v14 or later)
- npm or yarn

### Installation

1. Clone the repository
   ```
   git clone https://github.com/yourusername/uve.git
   cd uve
   ```

2. Install dependencies
   ```
   npm install
   ```

3. Run the development server
   ```
   npm run dev
   ```

4. Open your browser at `http://localhost:5173`

### Building for Production

```
npm run build
```

The built files will be in the `dist` directory.

## Usage

### Navigation

- Click on the 3D view to enable navigation mode
- Use WASD or arrow keys to move
- Use Q/E to move up/down
- Move the mouse to look around
- Press ESC to exit navigation mode

### Interaction

- Click on objects to select them
- Click "Enter Class" to navigate into a class sphere
- Click "Exit Class" to navigate back out
- Use the RDF view to edit the data model

## Development

### Code Structure

```
src/
├── core/               # Core system components
│   ├── eventBus.js     # Pub-sub messaging system
│   └── config.js       # System configuration
├── model/              # Data model components
│   ├── rdfModel.js     # RDF dataset management
│   ├── conceptModel.js # Conceptual model transformation
│   └── entityTypes/    # Domain entity definitions
├── view/               # View components
│   ├── rdfView/        # RDF editing view
│   └── threeView/      # Three.js visualization
├── examples/           # Example data models
│   └── foafExample.js  # FOAF example with 5 friends
├── util/               # Utility functions
│   └── idGenerator.js  # Unique ID generation
└── styles/             # CSS styles
    └── main.css        # Main styling
```

### Testing

Run the tests with:

```
npm test
```

## License

[MIT](LICENSE)

================
File: repomix.config.json
================
{
    "output": {
        "filePath": "./repomix-uve.md",
        "headerText": "UVE repo",
        "removeComments": false
    },
    "include": [
        "**/*"
    ],
    "ignore": {
        "useDefaultPatterns": false,
        "customPatterns": [
            ".git",
            "package-lock.json",
            "data",
            "docs",
            ".nyc_output",
            ".env",
            "**/_*",
            "node_modules",
            "*.log",
            "**/*repomix*.txt",
            "**/*repomix*.md",
            "**/*.html",
            "**/data/*",
            "**/*copy*.js",
            "**/conversations.json"
        ]
    }
}

================
File: vite.config.js
================
import { defineConfig } from 'vite';

export default defineConfig({
  server: {
    open: true
  },
  build: {
    outDir: 'dist',
    assetsDir: 'assets'
  },
  resolve: {
    alias: {
      '@': '/src'
    }
  },
  root: './', // Use project root
  publicDir: 'public'
});

================
File: webpack.config.js
================
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');

module.exports = {
  mode: 'development',
  entry: './src/js/app.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  devServer: {
    static: './dist',
    hot: true,
    open: true,
    port: 9000
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      filename: 'index.html',
    }),
    new CopyWebpackPlugin({
      patterns: [
        { from: 'src/assets', to: 'assets', noErrorOnMissing: true }
      ],
    }),
  ],
};
